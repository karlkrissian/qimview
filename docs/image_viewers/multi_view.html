<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qimview.image_viewers.multi_view API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qimview.image_viewers.multi_view</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from qimview.utils.qt_imports import *
from qimview.utils.utils import get_time
from qimview.utils.viewer_image  import *
from qimview.utils.menu_selection import MenuSelection
from qimview.utils.mvlabel import MVLabel
from qimview.cache import ImageCache

from qimview.image_viewers import *

from enum import Enum, auto
import math

import types
from typing import List, TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from qimview.image_viewers.image_viewer import ImageViewer

class ViewerType(Enum):
    QT_VIEWER             = auto()
    OPENGL_VIEWER         = auto()
    OPENGL_SHADERS_VIEWER = auto()


class MultiView(QtWidgets.QWidget):

    def __init__(self, parent=None, viewer_mode: ViewerType =ViewerType.QT_VIEWER, nb_viewers: int =1) -&gt; None:
        &#34;&#34;&#34;
        :param parent:
        :param viewer_mode:
        :param nb_viewers_used:
        &#34;&#34;&#34;
        QtWidgets.QWidget.__init__(self, parent)

        self.use_opengl = viewer_mode in [ViewerType.OPENGL_SHADERS_VIEWER, ViewerType.OPENGL_VIEWER]

        self.nb_viewers_used : int = nb_viewers
        self.allocated_image_viewers = []  # keep allocated image viewers here
        self.image_viewers = []
        self.image_viewer_classes = {
            ViewerType.QT_VIEWER:             QTImageViewer,
            ViewerType.OPENGL_VIEWER:         GLImageViewer,
            ViewerType.OPENGL_SHADERS_VIEWER: GLImageViewerShaders
        }
        self.image_viewer_class = self.image_viewer_classes[viewer_mode]

        # Create viewer instances
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
            self.image_viewers.append(viewer)

        self.viewer_mode = viewer_mode
        self.bold_font = QtGui.QFont()

        self.verbosity_LIGHT = 1
        self.verbosity_TIMING = 1 &lt;&lt; 2
        self.verbosity_TIMING_DETAILED = 1 &lt;&lt; 3
        self.verbosity_TRACE = 1 &lt;&lt; 4
        self.verbosity_DEBUG = 1 &lt;&lt; 5
        self.verbosity = 0

        # self.set_verbosity(self.verbosity_LIGHT)
        # self.set_verbosity(self.verbosity_TIMING_DETAILED)
        # self.set_verbosity(self.verbosity_TRACE)

        self.current_image_filename = None
        self.save_image_clipboard = False

        self.filter_params = ImageFilterParameters()
        self.filter_params_gui = ImageFilterParametersGui(self.filter_params)

        self.raw_bayer = {&#39;Read&#39;: None, &#39;Bayer0&#39;: ImageFormat.CH_GBRG, &#39;Bayer1&#39;: ImageFormat.CH_BGGR, &#39;Bayer2&#39;: ImageFormat.CH_RGGB, &#39;Bayer3&#39;: ImageFormat.CH_GRBG}
        self.default_raw_bayer = &#39;Read&#39;
        self.current_raw_bayer = self.default_raw_bayer

        # Number of viewers currently displayed
        self.nb_viewers_used : int = 0

        # save images of last visited row
        self.cache = ImageCache()
        self.image_dict = { }
        self.read_size = &#39;full&#39;
        self.image1 = dict()
        self.image2 = dict()
        self.button_layout = None
        self.message_cb = None
        self.replacing_widget = self.before_max_parent = None

        if &#39;ClickFocus&#39; in QtCore.Qt.FocusPolicy.__dict__:
            self.setFocusPolicy(QtCore.Qt.FocusPolicy.ClickFocus)
        else:
            self.setFocusPolicy(QtCore.Qt.ClickFocus)

        self.key_up_callback = None
        self.key_down_callback = None
        self.output_image_label = dict()

        self.output_label_current_image   : str = &#39;&#39;
        self.output_label_reference_image : str = &#39;&#39;
        self.add_context_menu()
        
        # Parameter to set the number of columns in the viewer grid layout
        # if 0: computed automatically
        self.max_columns : int = 0 

    def set_key_up_callback(self, c):
        self.key_up_callback = c

    def set_key_down_callback(self, c):
        self.key_down_callback = c

    def add_context_menu(self):
        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self._context_menu = QtWidgets.QMenu()
        self.viewer_modes = {}
        for v in ViewerType:
            self.viewer_modes[v.name] = v
        self._default_viewer_mode = ViewerType.QT_VIEWER.name
        self.viewer_mode_selection = MenuSelection(&#34;Viewer mode&#34;, 
            self._context_menu, self.viewer_modes, self._default_viewer_mode, self.update_viewer_mode)
        self._context_menu.addSeparator()
        action = self._context_menu.addAction(&#34;Reset viewers&#34;)
        action.triggered.connect(self.reset_viewers)

    def reset_viewers(self):
        for v in self.image_viewers:
            v.hide()
            self.viewer_grid_layout.removeWidget(v)
        self.allocated_image_viewers.clear()
        self.image_viewers.clear()
        # Create viewer instances
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
            self.image_viewers.append(viewer)
        self.set_number_of_viewers(self.nb_viewers_used)
        self.viewer_grid_layout.update()
        self.update_image()

    def update_viewer_mode(self):
        viewer_mode = self.viewer_mode_selection.get_selection_value()
        self.image_viewer_class = self.image_viewer_classes[viewer_mode]

    def show_context_menu(self, pos):
        # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
        self._context_menu.show()
        self._context_menu.popup( self.mapToGlobal(pos) )

    def set_cache_memory_bar(self, progress_bar):
        self.cache.set_memory_bar(progress_bar)

    def set_verbosity(self, flag, enable=True):
        &#34;&#34;&#34;
        :param v: verbosity flags
        :param b: boolean to enable or disable flag
        :return:
        &#34;&#34;&#34;
        if enable:
            self.verbosity = self.verbosity | flag
        else:
            self.verbosity = self.verbosity &amp; ~flag

    def check_verbosity(self, flag):
        return self.verbosity &amp; flag

    def print_log(self, mess):
        if self.verbosity &amp; self.verbosity_LIGHT:
            print(mess)

    def show_timing(self):
        return self.check_verbosity(self.verbosity_TIMING) or self.check_verbosity(self.verbosity_TIMING_DETAILED)

    def show_timing_detailed(self):
        return self.check_verbosity(self.verbosity_TIMING_DETAILED)

    def show_trace(self):
        return self.check_verbosity(self.verbosity_TRACE)

    def make_mouse_press(self, image_name):
        def mouse_press(obj, event):
            print(&#39;mouse_press&#39;)
            obj.update_image(image_name)

        return types.MethodType(mouse_press, self)

    def mouse_release(self, event):
        self.update_image(self.output_label_reference_image)

    def make_mouse_double_click(self, image_name):
        def mouse_double_click(obj, event):
            &#39;&#39;&#39;
            Sets the double clicked label as the reference image
            :param obj:
            :param event:
            &#39;&#39;&#39;
            print(&#39;mouse_double_click {}&#39;.format(image_name))
            obj.output_label_reference_image = image_name
            obj.output_label_current_image = obj.output_label_reference_image
            obj.update_image()

        return types.MethodType(mouse_double_click, self)

    def set_read_size(self, read_size):
        self.read_size = read_size
        # reset cache
        self.cache.reset()

    def update_image_intensity_event(self):
        self.update_image_parameters()

    def reset_intensities(self):
        self.filter_params_gui.reset_all()

    def update_image_parameters(self):
        &#39;&#39;&#39;
        Uses the variable self.output_label_current_image
        :return:
        &#39;&#39;&#39;
        self.print_log(&#39;update_image_parameters&#39;)
        update_start = get_time()

        for n in range(self.nb_viewers_used):
            self.image_viewers[n].filter_params.copy_from(self.filter_params)
            self.image_viewers[n].update()

        if self.show_timing():
            time_spent = get_time() - update_start
            self.print_log(&#34; Update image took {0:0.3f} sec.&#34;.format(time_spent))

    def set_images(self, images, set_viewers=False):
        self.print_log(f&#34;MultiView.set_images() {images}&#34;)
        if images.keys() == self.image_dict.keys():
            self.image_dict = images
            self.update_reference()
        else:
            self.image_dict = images
            self.update_image_buttons()

    def set_viewer_images(self):
        &#34;&#34;&#34;
        Set viewer images based on self.image_dict.keys()
        :return:
        &#34;&#34;&#34;
        # if set_viewers, we force the viewer layout and images based on the list
        # be sure to have enough image viewers allocated
        while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
        self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]
        image_names = list(self.image_dict.keys())
        for n in range(self.nb_viewers_used):
            if n &lt; len(image_names):
                self.image_viewers[n].image_name = image_names[n]
            else:
                self.image_viewers[n].image_name = image_names[len(image_names)-1]

    def update_reference(self) -&gt; None:
        reference_image = self.get_output_image(self.output_label_reference_image)
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewers[n]
            # set reference image
            viewer.set_image_ref(reference_image)

    def set_reference_label(self, ref: str, update_viewers=False) -&gt; None:
        try:
            if ref is not None:
                if ref!=self.output_label_reference_image:
                    self.output_label_reference_image = ref
                    if update_viewers:
                        self.update_reference()
        except Exception as e:
            print(f&#39; Failed to set reference label {e}&#39;)

    def update_image_buttons(self):
        # choose image to display
        self.clear_buttons()
        self.image_list = list(self.image_dict.keys())
        self.print_log(&#34;MultiView.update_image_buttons() {}&#34;.format(self.image_list))
        self.label = dict()
        for image_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if image_name != &#39;none&#39;:
                self.label[image_name] = MVLabel(image_name, self)
                self.label[image_name].setFrameShape(QtWidgets.QFrame.Panel)
                self.label[image_name].setFrameShadow(QtWidgets.QFrame.Sunken)
                # self.label[image_name].setLineWidth(3)
                self.label[image_name].setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
                # self.label[image_name].setFixedHeight(40)
                self.label[image_name].mousePressEvent = self.make_mouse_press(image_name)
                self.label[image_name].mouseReleaseEvent = self.mouse_release
                self.label[image_name].mouseDoubleClickEvent = self.make_mouse_double_click(image_name)
        self.create_buttons()

        # the crop area can be changed using the mouse wheel
        self.output_label_crop = (0., 0., 1., 1.)

        if len(self.image_list)&gt;0:
            self.output_label_current_image = self.image_list[0]
            self.set_reference_label(self.image_list[0], update_viewers=True)
        else:
            self.output_label_current_image = &#39;&#39;
            self.output_label_reference_image = &#39;&#39;

    def clear_buttons(self):
        if self.button_layout is not None:
            # start clearing the layout
            # for i in range(self.button_layout.count()): self.button_layout.itemAt(i).widget().close()
            self.print_log(f&#34;MultiView.clear_buttons() {self.image_list}&#34;)
            for image_name in reversed(self.image_list):
                if image_name in self.label:
                    self.button_layout.removeWidget(self.label[image_name])
                    self.label[image_name].close()

    def create_buttons(self):
        if self.button_layout is not None:
            max_grid_columns = 10
            idx = 0
            for image_name in self.image_list:
                # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
                if image_name != &#39;none&#39;:
                    self.button_layout.addWidget(self.label[image_name], idx // max_grid_columns, idx % max_grid_columns)
                    idx += 1

    def layout_buttons(self, vertical_layout):
        self.button_widget = QtWidgets.QWidget(self)
        self.button_layout = QtWidgets.QGridLayout()
        self.button_layout.setHorizontalSpacing(0)
        self.button_layout.setVerticalSpacing(0)
        # button_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        self.create_buttons()
        vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        # vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetNoConstraint)
        self.button_widget.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        self.button_widget.setLayout(self.button_layout)
        vertical_layout.addWidget(self.button_widget, 0, QtCore.Qt.AlignTop)

    def layout_parameters(self, parameters_layout):
        # Add Profiles and keep zoom options
        self.display_profiles = QtWidgets.QCheckBox(&#34;Profiles&#34;)
        self.display_profiles.stateChanged.connect(self.toggle_display_profiles)
        self.display_profiles.setChecked(False)
        parameters_layout.addWidget(self.display_profiles)
        self.keep_zoom = QtWidgets.QCheckBox(&#34;Keep zoom&#34;)
        self.keep_zoom.setChecked(False)
        parameters_layout.addWidget(self.keep_zoom)

        # Reset button
        self.reset_button = QtWidgets.QPushButton(&#34;reset&#34;)
        parameters_layout.addWidget(self.reset_button)
        self.reset_button.clicked.connect(self.reset_intensities)

        # Add color difference slider
        self.filter_params_gui.add_imdiff_factor(parameters_layout, self.update_image_intensity_event)

        # --- Saturation adjustment
        self.filter_params_gui.add_saturation(parameters_layout, self.update_image_intensity_event)
        # --- Black point adjustment
        self.filter_params_gui.add_blackpoint(parameters_layout, self.update_image_intensity_event)
        # --- white point adjustment
        self.filter_params_gui.add_whitepoint(parameters_layout, self.update_image_intensity_event)
        # --- Gamma adjustment
        self.filter_params_gui.add_gamma(parameters_layout, self.update_image_intensity_event)

    def layout_parameters_2(self, parameters2_layout):
        # --- G_R adjustment
        self.filter_params_gui.add_g_r(parameters2_layout, self.update_image_intensity_event)
        # --- G_B adjustment
        self.filter_params_gui.add_g_b(parameters2_layout, self.update_image_intensity_event)

    def update_layout(self):
        self.print_log(&#34;update_layout&#34;)
        vertical_layout = QtWidgets.QVBoxLayout()
        self.layout_buttons(vertical_layout)

        # First line of parameter control
        parameters_layout = QtWidgets.QHBoxLayout()
        self.layout_parameters(parameters_layout)
        vertical_layout.addLayout(parameters_layout, 1)

        # Second line of parameter control
        parameters2_layout = QtWidgets.QHBoxLayout()
        self.layout_parameters_2(parameters2_layout)
        vertical_layout.addLayout(parameters2_layout, 1)

        self.viewer_grid_layout = QtWidgets.QGridLayout()
        self.viewer_grid_layout.setHorizontalSpacing(1)
        self.viewer_grid_layout.setVerticalSpacing(1)
        self.set_number_of_viewers(1)
        vertical_layout.addLayout(self.viewer_grid_layout, 1)

        self.figures_widget = QtWidgets.QWidget()
        self.figures_layout = QtWidgets.QHBoxLayout()
        self.figures_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        # for the moment ignore this
        # self.figures_layout.addWidget(self.value_in_range_canvas)
        # self.figures_widget.setLayout(self.figures_layout)

        vertical_layout.addWidget(self.figures_widget)
        self.toggle_display_profiles()
        self.setLayout(vertical_layout)
        print(&#34;update_layout done&#34;)

    def toggle_display_profiles(self):
        self.figures_widget.setVisible(self.display_profiles.isChecked())
        self.update_image()

    def get_output_image(self, im_string_id):
        &#34;&#34;&#34;
        Search for the image with given label in the current row
        if not in cache reads it and add it to the cache
        :param im_string_id: string that identifies the image to display
        :return:
        &#34;&#34;&#34;
        # print(f&#34;get_output_image({im_string_id}) &#34;)
        start = get_time()

        image_filename = self.image_dict[im_string_id]
        image_transform = None
        self.print_log(f&#34;MultiView.get_output_image() image_filename:{image_filename}&#34;)

        image_data, _ = self.cache.get_image(image_filename, self.read_size, verbose=self.show_timing_detailed(),
                                             use_RGB=not self.use_opengl, image_transform=image_transform)

        if image_data is not None:
            self.output_image_label[im_string_id] = image_filename
            output_image = image_data
        else:
            print(f&#34;failed to get image {im_string_id}: {image_filename}&#34;)
            return None

        if self.show_timing_detailed():
            print(f&#34; get_output_image took {int((get_time() - start)*1000+0.5)} ms&#34;.format)

        # force image bayer information if selected from menu
        res = output_image
        set_bayer = self.raw_bayer[self.current_raw_bayer]
        if res.channels in [ImageFormat.CH_BGGR, ImageFormat.CH_GBRG, ImageFormat.CH_GRBG, ImageFormat.CH_RGGB] and set_bayer is not None:
            print(f&#34;Setting bayer {set_bayer}&#34;)
            res.channels = set_bayer

        return res

    def set_message_callback(self, message_cb):
        self.message_cb = message_cb

    def setMessage(self, mess):
        if self.message_cb is not None:
            self.message_cb(mess)

    def cache_read_images(self, image_filenames: List[str], reload: bool =False) -&gt; None:
        &#34;&#34;&#34; Read the list of images into the cache, with option to reload them from disk

        Args:
            image_filenames (List[str]): list of image filenames
            reload (bool, optional): reload removes first the images from the ImageCache 
                before adding them. Defaults to False.
        &#34;&#34;&#34;        
        # print(f&#34;cache_read_images({image_filenames}) &#34;)
        image_transform = None
        if reload:
            for f in image_filenames:
                self.cache.remove(f)
        self.cache.add_images(image_filenames, self.read_size, verbose=False, use_RGB=not self.use_opengl,
                             image_transform=image_transform)

    def update_label_fonts(self):
        # Update selected image label, we could do it later too
        for im_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if im_name != &#39;none&#39;:
                is_bold      = im_name == self.output_label_current_image
                is_underline = im_name == self.output_label_reference_image
                is_bold |= is_underline
                self.bold_font.setBold(is_bold)
                self.bold_font.setUnderline(is_underline)
                self.bold_font.setPointSize(8)
                self.label[im_name].setFont(self.bold_font)
                self.label[im_name].setWordWrap(True)
            # self.label[im_name].setMaximumWidth(160)

    def update_image(self, image_name=None, reload=False):
        &#34;&#34;&#34;
        Uses the variable self.output_label_current_image
        :return:
        &#34;&#34;&#34;
        self.print_log(&#39;update_image {} current: {}&#39;.format(image_name, self.output_label_current_image))
        update_image_start = get_time()

        # Define the current selected image
        if image_name is not None:
            self.output_label_current_image = image_name
        if self.output_label_current_image == &#34;&#34;:
            return

        if self.image_dict[self.output_label_current_image] is None:
            print(&#34; No image filename for current image&#34;)
            return

        self.update_label_fonts()

        # find first active window
        first_active_window = 0
        for n in range(self.nb_viewers_used):
            self.image_viewers[n].display_timing = self.show_timing()&gt;0
            if self.image_viewers[n].is_active():
                first_active_window = n
                break

        # Read images in parallel to improve preformances
        # list all required image filenames
        # set all viewers image names (labels)
        image_filenames = [self.image_dict[self.output_label_current_image]]
        # define image associated to each used viewer and add it to the list of images to get
        for n in range(self.nb_viewers_used):
            viewer : ImageViewer = self.image_viewers[n]
            # Set active only the first active window
            viewer.set_active(n == first_active_window)
            if viewer.get_image() is None:
                if n &lt; len(self.image_list):
                    viewer.image_name = self.image_list[n]
                    image_filenames.append(self.image_dict[self.image_list[n]])
                else:
                    viewer.image_name = self.output_label_current_image
            else:
                # image_name should belong to image_dict
                if viewer.image_name in self.image_dict:
                    image_filenames.append(self.image_dict[viewer.image_name])
                else:
                    viewer.image_name = self.output_label_current_image

        # remove duplicates
        image_filenames = list(set(image_filenames))
        # print(f&#34;image filenames {image_filenames}&#34;)
        self.cache_read_images(image_filenames, reload=reload)

        try:
            current_image = self.get_output_image(self.output_label_current_image)
            if current_image is None:
                return
        except Exception as e:
            print(&#34;Error: failed to get image {}: {}&#34;.format(self.output_label_current_image, e))
            return

        # print(f&#34;cur {self.output_label_current_image}&#34;)
        current_filename = self.output_image_label[self.output_label_current_image]

        if self.show_timing_detailed():
            time_spent = get_time() - update_image_start

        self.setMessage(&#34;Image: {0}&#34;.format(current_filename))

        current_viewer = self.image_viewers[first_active_window]
        if self.save_image_clipboard:
            print(&#34;set save image to clipboard&#34;)
            current_viewer.set_clipboard(self.clip, True)
        current_viewer.set_active(True)
        current_viewer.image_name = self.output_label_current_image
        current_viewer.set_image(current_image)
        if self.save_image_clipboard:
            print(&#34;end save image to clipboard&#34;)
            current_viewer.set_clipboard(None, False)

        # print(f&#34;ref {self.output_label_reference_image}&#34;)
        if self.output_label_reference_image==self.output_label_current_image:
            reference_image = current_image
        else:
            reference_image = self.get_output_image(self.output_label_reference_image)

        if self.nb_viewers_used &gt;= 2:
            prev_n = first_active_window
            for n in range(1, self.nb_viewers_used):
                n1 = (first_active_window + n) % self.nb_viewers_used
                viewer = self.image_viewers[n1]
                # viewer image has already been defined
                # try to update corresponding images in row
                try:
                    viewer_image = self.get_output_image(viewer.image_name)
                except Exception as e:
                    print(&#34;Error: failed to get image {}: {}&#34;.format(viewer.image_name, e))
                    viewer.set_image(current_image)
                else:
                    viewer.set_image(viewer_image)

                # set reference image
                viewer.set_image_ref(reference_image)

                self.image_viewers[prev_n].set_synchronize(viewer)
                prev_n = n1
            # Create a synchronization loop
            if prev_n != first_active_window:
                self.image_viewers[prev_n].set_synchronize(self.image_viewers[first_active_window])

        # Be sure to show the required viewers
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewers[n]
            # print(f&#34;show viewer {n}&#34;)
            # Note: calling show in any case seems to avoid double calls to paint event that update() triggers
            # viewer.show()
            if viewer.isHidden():
                # print(f&#34;show viewer {n}&#34;)
                viewer.show()
            else:
                # print(f&#34;update viewer {n}&#34;)
                viewer.update()


        # self.image_scroll_area.adjustSize()
        # if self.show_timing():
        print(f&#34; Update image took {(get_time() - update_image_start)*1000:0.0f} ms&#34;)

    def set_number_of_viewers(self, nb_viewers: int = 1, max_columns : int = 0) -&gt; None:
        self.print_log(&#34;*** set_number_of_viewers()&#34;)

        # 1. remove current viewers from grid layout
        # self.viewer_grid_layout.hide()
        for v in self.image_viewers:
            v.hide()
            self.viewer_grid_layout.removeWidget(v)

        self.nb_viewers_used : int = nb_viewers
        print(f&#34;max_columns = {max_columns}&#34;)
        if max_columns&gt;0:
            row_length = min(self.nb_viewers_used, max_columns)
            col_length = int(math.ceil(self.nb_viewers_used / row_length))
        else:
            # Find best configuration to fill the space based on image size and widget size?
            col_length = int(math.sqrt(self.nb_viewers_used))
            row_length = int(math.ceil(self.nb_viewers_used / col_length))
        self.print_log(&#39;col_length = {} row_length = {}&#39;.format(col_length, row_length))
        # be sure to have enough image viewers allocated
        while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)

        self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]

        for n in range(self.nb_viewers_used):
            self.viewer_grid_layout.addWidget(self.image_viewers[n], int(n / float(row_length)), n % row_length)
            self.image_viewers[n].hide()

        # for n in range(self.nb_viewers_used):
        #     print(&#34;Viewer {} size {}&#34;.format(n, (self.image_viewers[n].width(), self.image_viewers[n].height())))

    def set_number_of_viewers_callback(self):
        self.set_number_of_viewers()
        self.viewer_grid_layout.update()
        self.update_image()

    def keyReleaseEvent(self, event):
        if type(event) == QtGui.QKeyEvent:
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
            if modifiers &amp; (QtCore.Qt.AltModifier | QtCore.Qt.ControlModifier):
                event.accept()
            # else:
            #     try:
            #         # reset reference image
            #         if self.output_label_current_image != self.output_label_reference_image:
            #             self.update_image(self.output_label_reference_image)
            #     except Exception as e:
            #         print(&#34; Error: {}&#34;.format(e))

    def find_in_layout(self, layout: QtWidgets.QLayout) -&gt; Optional[QtWidgets.QLayout]:
        &#34;&#34;&#34; Search Recursivement in Layouts for the current widget

        Args:
            layout (QtWidgets.QLayout): input layout for search

        Returns:
            layout containing the current widget or None if not found
        &#34;&#34;&#34;
        print(&#34;find_in_layout()&#34;)
        if layout.indexOf(self) != -1: return layout
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item.widget() == self: return layout
            if (l := item.layout()) and (found:=self.find_in_layout(l)): return l
        print(&#34;find_in_layout() return None&#34;)
        return None

    def toggle_fullscreen(self, event):
        print(f&#34;toggle_fullscreen&#34;)
        if not issubclass(self.__class__,QtWidgets.QWidget):
            print(f&#34;Cannot use toggle_fullscreen on a class that is not a QWidget&#34;)
            return
        # Should be inside a layout
        if self.before_max_parent is None:
            print(f&#34;self.parent() is not None {self.parent() is not None}&#34;)
            print(f&#34;self.parent().layout() {self.parent().layout()} &#34;)
            if self.parent() is not None and (playout := self.parent().layout()) is not None:
                if self.find_in_layout(playout):
                    self.before_max_parent = self.parent()
                    self.replacing_widget = QtWidgets.QWidget(self.before_max_parent)
                    self.parent().layout().replaceWidget(self, self.replacing_widget)
                    # We need to go up from the parent widget to the main window to get its geometry
                    # so that the fullscreen is display on the same monitor
                    toplevel_parent : Optional[QtWidgets.QWidget] = self.parentWidget()
                    while toplevel_parent.parentWidget(): toplevel_parent = toplevel_parent.parentWidget()
                    self.setParent(None)
                    if toplevel_parent: self.setGeometry(toplevel_parent.geometry())
                    self.showFullScreen()
                    event.accept()
                    return
        if self.before_max_parent is not None:
            self.setParent(self.before_max_parent)
            self.parent().layout().replaceWidget(self.replacing_widget, self)
            self.replacing_widget = self.before_max_parent = None
            # self.resize(self.before_max_size)
            self.show()
            self.parent().update()
            self.setFocus()
            event.accept()
            return



    def keyPressEvent(self, event):
        if type(event) == QtGui.QKeyEvent:
            # print(&#34;key is &#34;, event.key())
            self.print_log(f&#34; QKeySequence() {QtGui.QKeySequence(event.key()).toString()}&#34;)
            # print( QtGui.QKeySequence(event.key()).toString())
            # print(f&#34; capslock: {event.getModifierState(&#39;CapsLock&#39;)}&#34;)
            if self.show_trace():
                print(&#34;key is &#34;, event.key())
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            # F1: open help in browser
            if event.key() == QtCore.Qt.Key_F1:
                import qimview
                mb = QtWidgets.QMessageBox(self)
                mb.setWindowTitle(f&#34;qimview {qimview.__version__}: MultiView help&#34;)
                mb.setTextFormat(QtCore.Qt.TextFormat.RichText)
                mb.setText(
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki&#39;&gt;qimview&lt;/a&gt;&lt;br&gt;&#34;
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/4.-Multi%E2%80%90image-viewer&#39;&gt;MultiImage Viewer&lt;/a&gt;&lt;br&gt;&#34;
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/3.-Image-Viewers&#39;&gt;Image Viewer&lt;/a&gt;&#34;)
                mb.exec()
                event.accept()
                return

            # F5: reload images
            if event.key() == QtCore.Qt.Key_F5:
                self.update_image(reload=True)
                event.accept()
                return

            if event.key() == QtCore.Qt.Key_F11:
                # Should be inside a layout
                print(&#34;MultiView F11 pressed&#34;)
                self.toggle_fullscreen(event)
                return

            # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
            if modifiers &amp; QtCore.Qt.AltModifier:
                for n in range(len(self.image_list)):
                    if self.image_list[n] is not None:
                        if event.key() == QtCore.Qt.Key_0 + n:
                            if self.output_label_current_image != self.image_list[n]:
                                # with Alt+Ctrl, change reference image
                                # if modifiers &amp; QtCore.Qt.ControlModifier:
                                #     self.set_reference_label(self.image_list[n])
                                self.update_image(self.image_list[n])
                                self.setFocus()
                                return
                event.accept()
                return

            if event.modifiers() &amp; QtCore.Qt.ControlModifier:
                # allow to switch between images by pressing Ctrl+&#39;image position&#39; (Ctrl+0, Ctrl+1, etc)
                for n in range(len(self.image_list)):
                    if self.image_list[n] != &#39;none&#39;:
                        if event.key() == QtCore.Qt.Key_0 + n:
                            if self.output_label_current_image != self.image_list[n]:
                                self.set_reference_label(self.image_list[n], update_viewers=True)
                                self.update_image()
                                event.accept()
                                return
                return
            # print(f&#34;event.modifiers {event.modifiers()}&#34;)
            # if not event.modifiers():
            for n in range(1, 10):
                if event.key() == QtCore.Qt.Key_0 + n:
                    self.set_number_of_viewers(n)
                    self.viewer_grid_layout.update()
                    self.update_image()
                    self.setFocus()
                    event.accept()
                    return

            if event.key() == QtCore.Qt.Key_Up:
                if self.key_up_callback is not None:
                    self.key_up_callback()
                event.accept()
                return

            if event.key() == QtCore.Qt.Key_Down:
                if self.key_down_callback is not None:
                    self.key_down_callback()
                event.accept()
                return

            nb_images = len(self.image_list)
            if event.key() == QtCore.Qt.Key_Left:
                for n in range(nb_images):
                    if self.output_label_current_image == self.image_list[n]:
                        print(f&#34;setting new image index {(n+nb_images-1)%nb_images}&#34;)
                        self.update_image(self.image_list[(n+nb_images-1)%nb_images])
                        event.accept()
                        return

            if event.key() == QtCore.Qt.Key_Right:
                for n in range(nb_images):
                    if self.output_label_current_image == self.image_list[n]:
                        print(f&#34;setting new image index {(n+nb_images+1)%nb_images}&#34;)
                        self.update_image(self.image_list[(n+1)%nb_images])
                        event.accept()
                        return
                
            # G: display number of columns
            if event.key() == QtCore.Qt.Key_G:
                self.max_columns = int ((self.max_columns + 1) % self.nb_viewers_used + 1)
                self.set_number_of_viewers(self.nb_viewers_used, max_columns=self.max_columns)
                self.update_image(reload=True)
                self.setFocus()
                event.accept()
                return

        else:
            event.ignore()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qimview.image_viewers.multi_view.MultiView"><code class="flex name class">
<span>class <span class="ident">MultiView</span></span>
<span>(</span><span>parent=None, viewer_mode: <a title="qimview.image_viewers.multi_view.ViewerType" href="#qimview.image_viewers.multi_view.ViewerType">ViewerType</a> = ViewerType.QT_VIEWER, nb_viewers: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>QWidget(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p>:param parent:
:param viewer_mode:
:param nb_viewers_used:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiView(QtWidgets.QWidget):

    def __init__(self, parent=None, viewer_mode: ViewerType =ViewerType.QT_VIEWER, nb_viewers: int =1) -&gt; None:
        &#34;&#34;&#34;
        :param parent:
        :param viewer_mode:
        :param nb_viewers_used:
        &#34;&#34;&#34;
        QtWidgets.QWidget.__init__(self, parent)

        self.use_opengl = viewer_mode in [ViewerType.OPENGL_SHADERS_VIEWER, ViewerType.OPENGL_VIEWER]

        self.nb_viewers_used : int = nb_viewers
        self.allocated_image_viewers = []  # keep allocated image viewers here
        self.image_viewers = []
        self.image_viewer_classes = {
            ViewerType.QT_VIEWER:             QTImageViewer,
            ViewerType.OPENGL_VIEWER:         GLImageViewer,
            ViewerType.OPENGL_SHADERS_VIEWER: GLImageViewerShaders
        }
        self.image_viewer_class = self.image_viewer_classes[viewer_mode]

        # Create viewer instances
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
            self.image_viewers.append(viewer)

        self.viewer_mode = viewer_mode
        self.bold_font = QtGui.QFont()

        self.verbosity_LIGHT = 1
        self.verbosity_TIMING = 1 &lt;&lt; 2
        self.verbosity_TIMING_DETAILED = 1 &lt;&lt; 3
        self.verbosity_TRACE = 1 &lt;&lt; 4
        self.verbosity_DEBUG = 1 &lt;&lt; 5
        self.verbosity = 0

        # self.set_verbosity(self.verbosity_LIGHT)
        # self.set_verbosity(self.verbosity_TIMING_DETAILED)
        # self.set_verbosity(self.verbosity_TRACE)

        self.current_image_filename = None
        self.save_image_clipboard = False

        self.filter_params = ImageFilterParameters()
        self.filter_params_gui = ImageFilterParametersGui(self.filter_params)

        self.raw_bayer = {&#39;Read&#39;: None, &#39;Bayer0&#39;: ImageFormat.CH_GBRG, &#39;Bayer1&#39;: ImageFormat.CH_BGGR, &#39;Bayer2&#39;: ImageFormat.CH_RGGB, &#39;Bayer3&#39;: ImageFormat.CH_GRBG}
        self.default_raw_bayer = &#39;Read&#39;
        self.current_raw_bayer = self.default_raw_bayer

        # Number of viewers currently displayed
        self.nb_viewers_used : int = 0

        # save images of last visited row
        self.cache = ImageCache()
        self.image_dict = { }
        self.read_size = &#39;full&#39;
        self.image1 = dict()
        self.image2 = dict()
        self.button_layout = None
        self.message_cb = None
        self.replacing_widget = self.before_max_parent = None

        if &#39;ClickFocus&#39; in QtCore.Qt.FocusPolicy.__dict__:
            self.setFocusPolicy(QtCore.Qt.FocusPolicy.ClickFocus)
        else:
            self.setFocusPolicy(QtCore.Qt.ClickFocus)

        self.key_up_callback = None
        self.key_down_callback = None
        self.output_image_label = dict()

        self.output_label_current_image   : str = &#39;&#39;
        self.output_label_reference_image : str = &#39;&#39;
        self.add_context_menu()
        
        # Parameter to set the number of columns in the viewer grid layout
        # if 0: computed automatically
        self.max_columns : int = 0 

    def set_key_up_callback(self, c):
        self.key_up_callback = c

    def set_key_down_callback(self, c):
        self.key_down_callback = c

    def add_context_menu(self):
        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self._context_menu = QtWidgets.QMenu()
        self.viewer_modes = {}
        for v in ViewerType:
            self.viewer_modes[v.name] = v
        self._default_viewer_mode = ViewerType.QT_VIEWER.name
        self.viewer_mode_selection = MenuSelection(&#34;Viewer mode&#34;, 
            self._context_menu, self.viewer_modes, self._default_viewer_mode, self.update_viewer_mode)
        self._context_menu.addSeparator()
        action = self._context_menu.addAction(&#34;Reset viewers&#34;)
        action.triggered.connect(self.reset_viewers)

    def reset_viewers(self):
        for v in self.image_viewers:
            v.hide()
            self.viewer_grid_layout.removeWidget(v)
        self.allocated_image_viewers.clear()
        self.image_viewers.clear()
        # Create viewer instances
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
            self.image_viewers.append(viewer)
        self.set_number_of_viewers(self.nb_viewers_used)
        self.viewer_grid_layout.update()
        self.update_image()

    def update_viewer_mode(self):
        viewer_mode = self.viewer_mode_selection.get_selection_value()
        self.image_viewer_class = self.image_viewer_classes[viewer_mode]

    def show_context_menu(self, pos):
        # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
        self._context_menu.show()
        self._context_menu.popup( self.mapToGlobal(pos) )

    def set_cache_memory_bar(self, progress_bar):
        self.cache.set_memory_bar(progress_bar)

    def set_verbosity(self, flag, enable=True):
        &#34;&#34;&#34;
        :param v: verbosity flags
        :param b: boolean to enable or disable flag
        :return:
        &#34;&#34;&#34;
        if enable:
            self.verbosity = self.verbosity | flag
        else:
            self.verbosity = self.verbosity &amp; ~flag

    def check_verbosity(self, flag):
        return self.verbosity &amp; flag

    def print_log(self, mess):
        if self.verbosity &amp; self.verbosity_LIGHT:
            print(mess)

    def show_timing(self):
        return self.check_verbosity(self.verbosity_TIMING) or self.check_verbosity(self.verbosity_TIMING_DETAILED)

    def show_timing_detailed(self):
        return self.check_verbosity(self.verbosity_TIMING_DETAILED)

    def show_trace(self):
        return self.check_verbosity(self.verbosity_TRACE)

    def make_mouse_press(self, image_name):
        def mouse_press(obj, event):
            print(&#39;mouse_press&#39;)
            obj.update_image(image_name)

        return types.MethodType(mouse_press, self)

    def mouse_release(self, event):
        self.update_image(self.output_label_reference_image)

    def make_mouse_double_click(self, image_name):
        def mouse_double_click(obj, event):
            &#39;&#39;&#39;
            Sets the double clicked label as the reference image
            :param obj:
            :param event:
            &#39;&#39;&#39;
            print(&#39;mouse_double_click {}&#39;.format(image_name))
            obj.output_label_reference_image = image_name
            obj.output_label_current_image = obj.output_label_reference_image
            obj.update_image()

        return types.MethodType(mouse_double_click, self)

    def set_read_size(self, read_size):
        self.read_size = read_size
        # reset cache
        self.cache.reset()

    def update_image_intensity_event(self):
        self.update_image_parameters()

    def reset_intensities(self):
        self.filter_params_gui.reset_all()

    def update_image_parameters(self):
        &#39;&#39;&#39;
        Uses the variable self.output_label_current_image
        :return:
        &#39;&#39;&#39;
        self.print_log(&#39;update_image_parameters&#39;)
        update_start = get_time()

        for n in range(self.nb_viewers_used):
            self.image_viewers[n].filter_params.copy_from(self.filter_params)
            self.image_viewers[n].update()

        if self.show_timing():
            time_spent = get_time() - update_start
            self.print_log(&#34; Update image took {0:0.3f} sec.&#34;.format(time_spent))

    def set_images(self, images, set_viewers=False):
        self.print_log(f&#34;MultiView.set_images() {images}&#34;)
        if images.keys() == self.image_dict.keys():
            self.image_dict = images
            self.update_reference()
        else:
            self.image_dict = images
            self.update_image_buttons()

    def set_viewer_images(self):
        &#34;&#34;&#34;
        Set viewer images based on self.image_dict.keys()
        :return:
        &#34;&#34;&#34;
        # if set_viewers, we force the viewer layout and images based on the list
        # be sure to have enough image viewers allocated
        while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
        self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]
        image_names = list(self.image_dict.keys())
        for n in range(self.nb_viewers_used):
            if n &lt; len(image_names):
                self.image_viewers[n].image_name = image_names[n]
            else:
                self.image_viewers[n].image_name = image_names[len(image_names)-1]

    def update_reference(self) -&gt; None:
        reference_image = self.get_output_image(self.output_label_reference_image)
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewers[n]
            # set reference image
            viewer.set_image_ref(reference_image)

    def set_reference_label(self, ref: str, update_viewers=False) -&gt; None:
        try:
            if ref is not None:
                if ref!=self.output_label_reference_image:
                    self.output_label_reference_image = ref
                    if update_viewers:
                        self.update_reference()
        except Exception as e:
            print(f&#39; Failed to set reference label {e}&#39;)

    def update_image_buttons(self):
        # choose image to display
        self.clear_buttons()
        self.image_list = list(self.image_dict.keys())
        self.print_log(&#34;MultiView.update_image_buttons() {}&#34;.format(self.image_list))
        self.label = dict()
        for image_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if image_name != &#39;none&#39;:
                self.label[image_name] = MVLabel(image_name, self)
                self.label[image_name].setFrameShape(QtWidgets.QFrame.Panel)
                self.label[image_name].setFrameShadow(QtWidgets.QFrame.Sunken)
                # self.label[image_name].setLineWidth(3)
                self.label[image_name].setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
                # self.label[image_name].setFixedHeight(40)
                self.label[image_name].mousePressEvent = self.make_mouse_press(image_name)
                self.label[image_name].mouseReleaseEvent = self.mouse_release
                self.label[image_name].mouseDoubleClickEvent = self.make_mouse_double_click(image_name)
        self.create_buttons()

        # the crop area can be changed using the mouse wheel
        self.output_label_crop = (0., 0., 1., 1.)

        if len(self.image_list)&gt;0:
            self.output_label_current_image = self.image_list[0]
            self.set_reference_label(self.image_list[0], update_viewers=True)
        else:
            self.output_label_current_image = &#39;&#39;
            self.output_label_reference_image = &#39;&#39;

    def clear_buttons(self):
        if self.button_layout is not None:
            # start clearing the layout
            # for i in range(self.button_layout.count()): self.button_layout.itemAt(i).widget().close()
            self.print_log(f&#34;MultiView.clear_buttons() {self.image_list}&#34;)
            for image_name in reversed(self.image_list):
                if image_name in self.label:
                    self.button_layout.removeWidget(self.label[image_name])
                    self.label[image_name].close()

    def create_buttons(self):
        if self.button_layout is not None:
            max_grid_columns = 10
            idx = 0
            for image_name in self.image_list:
                # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
                if image_name != &#39;none&#39;:
                    self.button_layout.addWidget(self.label[image_name], idx // max_grid_columns, idx % max_grid_columns)
                    idx += 1

    def layout_buttons(self, vertical_layout):
        self.button_widget = QtWidgets.QWidget(self)
        self.button_layout = QtWidgets.QGridLayout()
        self.button_layout.setHorizontalSpacing(0)
        self.button_layout.setVerticalSpacing(0)
        # button_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        self.create_buttons()
        vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        # vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetNoConstraint)
        self.button_widget.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        self.button_widget.setLayout(self.button_layout)
        vertical_layout.addWidget(self.button_widget, 0, QtCore.Qt.AlignTop)

    def layout_parameters(self, parameters_layout):
        # Add Profiles and keep zoom options
        self.display_profiles = QtWidgets.QCheckBox(&#34;Profiles&#34;)
        self.display_profiles.stateChanged.connect(self.toggle_display_profiles)
        self.display_profiles.setChecked(False)
        parameters_layout.addWidget(self.display_profiles)
        self.keep_zoom = QtWidgets.QCheckBox(&#34;Keep zoom&#34;)
        self.keep_zoom.setChecked(False)
        parameters_layout.addWidget(self.keep_zoom)

        # Reset button
        self.reset_button = QtWidgets.QPushButton(&#34;reset&#34;)
        parameters_layout.addWidget(self.reset_button)
        self.reset_button.clicked.connect(self.reset_intensities)

        # Add color difference slider
        self.filter_params_gui.add_imdiff_factor(parameters_layout, self.update_image_intensity_event)

        # --- Saturation adjustment
        self.filter_params_gui.add_saturation(parameters_layout, self.update_image_intensity_event)
        # --- Black point adjustment
        self.filter_params_gui.add_blackpoint(parameters_layout, self.update_image_intensity_event)
        # --- white point adjustment
        self.filter_params_gui.add_whitepoint(parameters_layout, self.update_image_intensity_event)
        # --- Gamma adjustment
        self.filter_params_gui.add_gamma(parameters_layout, self.update_image_intensity_event)

    def layout_parameters_2(self, parameters2_layout):
        # --- G_R adjustment
        self.filter_params_gui.add_g_r(parameters2_layout, self.update_image_intensity_event)
        # --- G_B adjustment
        self.filter_params_gui.add_g_b(parameters2_layout, self.update_image_intensity_event)

    def update_layout(self):
        self.print_log(&#34;update_layout&#34;)
        vertical_layout = QtWidgets.QVBoxLayout()
        self.layout_buttons(vertical_layout)

        # First line of parameter control
        parameters_layout = QtWidgets.QHBoxLayout()
        self.layout_parameters(parameters_layout)
        vertical_layout.addLayout(parameters_layout, 1)

        # Second line of parameter control
        parameters2_layout = QtWidgets.QHBoxLayout()
        self.layout_parameters_2(parameters2_layout)
        vertical_layout.addLayout(parameters2_layout, 1)

        self.viewer_grid_layout = QtWidgets.QGridLayout()
        self.viewer_grid_layout.setHorizontalSpacing(1)
        self.viewer_grid_layout.setVerticalSpacing(1)
        self.set_number_of_viewers(1)
        vertical_layout.addLayout(self.viewer_grid_layout, 1)

        self.figures_widget = QtWidgets.QWidget()
        self.figures_layout = QtWidgets.QHBoxLayout()
        self.figures_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        # for the moment ignore this
        # self.figures_layout.addWidget(self.value_in_range_canvas)
        # self.figures_widget.setLayout(self.figures_layout)

        vertical_layout.addWidget(self.figures_widget)
        self.toggle_display_profiles()
        self.setLayout(vertical_layout)
        print(&#34;update_layout done&#34;)

    def toggle_display_profiles(self):
        self.figures_widget.setVisible(self.display_profiles.isChecked())
        self.update_image()

    def get_output_image(self, im_string_id):
        &#34;&#34;&#34;
        Search for the image with given label in the current row
        if not in cache reads it and add it to the cache
        :param im_string_id: string that identifies the image to display
        :return:
        &#34;&#34;&#34;
        # print(f&#34;get_output_image({im_string_id}) &#34;)
        start = get_time()

        image_filename = self.image_dict[im_string_id]
        image_transform = None
        self.print_log(f&#34;MultiView.get_output_image() image_filename:{image_filename}&#34;)

        image_data, _ = self.cache.get_image(image_filename, self.read_size, verbose=self.show_timing_detailed(),
                                             use_RGB=not self.use_opengl, image_transform=image_transform)

        if image_data is not None:
            self.output_image_label[im_string_id] = image_filename
            output_image = image_data
        else:
            print(f&#34;failed to get image {im_string_id}: {image_filename}&#34;)
            return None

        if self.show_timing_detailed():
            print(f&#34; get_output_image took {int((get_time() - start)*1000+0.5)} ms&#34;.format)

        # force image bayer information if selected from menu
        res = output_image
        set_bayer = self.raw_bayer[self.current_raw_bayer]
        if res.channels in [ImageFormat.CH_BGGR, ImageFormat.CH_GBRG, ImageFormat.CH_GRBG, ImageFormat.CH_RGGB] and set_bayer is not None:
            print(f&#34;Setting bayer {set_bayer}&#34;)
            res.channels = set_bayer

        return res

    def set_message_callback(self, message_cb):
        self.message_cb = message_cb

    def setMessage(self, mess):
        if self.message_cb is not None:
            self.message_cb(mess)

    def cache_read_images(self, image_filenames: List[str], reload: bool =False) -&gt; None:
        &#34;&#34;&#34; Read the list of images into the cache, with option to reload them from disk

        Args:
            image_filenames (List[str]): list of image filenames
            reload (bool, optional): reload removes first the images from the ImageCache 
                before adding them. Defaults to False.
        &#34;&#34;&#34;        
        # print(f&#34;cache_read_images({image_filenames}) &#34;)
        image_transform = None
        if reload:
            for f in image_filenames:
                self.cache.remove(f)
        self.cache.add_images(image_filenames, self.read_size, verbose=False, use_RGB=not self.use_opengl,
                             image_transform=image_transform)

    def update_label_fonts(self):
        # Update selected image label, we could do it later too
        for im_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if im_name != &#39;none&#39;:
                is_bold      = im_name == self.output_label_current_image
                is_underline = im_name == self.output_label_reference_image
                is_bold |= is_underline
                self.bold_font.setBold(is_bold)
                self.bold_font.setUnderline(is_underline)
                self.bold_font.setPointSize(8)
                self.label[im_name].setFont(self.bold_font)
                self.label[im_name].setWordWrap(True)
            # self.label[im_name].setMaximumWidth(160)

    def update_image(self, image_name=None, reload=False):
        &#34;&#34;&#34;
        Uses the variable self.output_label_current_image
        :return:
        &#34;&#34;&#34;
        self.print_log(&#39;update_image {} current: {}&#39;.format(image_name, self.output_label_current_image))
        update_image_start = get_time()

        # Define the current selected image
        if image_name is not None:
            self.output_label_current_image = image_name
        if self.output_label_current_image == &#34;&#34;:
            return

        if self.image_dict[self.output_label_current_image] is None:
            print(&#34; No image filename for current image&#34;)
            return

        self.update_label_fonts()

        # find first active window
        first_active_window = 0
        for n in range(self.nb_viewers_used):
            self.image_viewers[n].display_timing = self.show_timing()&gt;0
            if self.image_viewers[n].is_active():
                first_active_window = n
                break

        # Read images in parallel to improve preformances
        # list all required image filenames
        # set all viewers image names (labels)
        image_filenames = [self.image_dict[self.output_label_current_image]]
        # define image associated to each used viewer and add it to the list of images to get
        for n in range(self.nb_viewers_used):
            viewer : ImageViewer = self.image_viewers[n]
            # Set active only the first active window
            viewer.set_active(n == first_active_window)
            if viewer.get_image() is None:
                if n &lt; len(self.image_list):
                    viewer.image_name = self.image_list[n]
                    image_filenames.append(self.image_dict[self.image_list[n]])
                else:
                    viewer.image_name = self.output_label_current_image
            else:
                # image_name should belong to image_dict
                if viewer.image_name in self.image_dict:
                    image_filenames.append(self.image_dict[viewer.image_name])
                else:
                    viewer.image_name = self.output_label_current_image

        # remove duplicates
        image_filenames = list(set(image_filenames))
        # print(f&#34;image filenames {image_filenames}&#34;)
        self.cache_read_images(image_filenames, reload=reload)

        try:
            current_image = self.get_output_image(self.output_label_current_image)
            if current_image is None:
                return
        except Exception as e:
            print(&#34;Error: failed to get image {}: {}&#34;.format(self.output_label_current_image, e))
            return

        # print(f&#34;cur {self.output_label_current_image}&#34;)
        current_filename = self.output_image_label[self.output_label_current_image]

        if self.show_timing_detailed():
            time_spent = get_time() - update_image_start

        self.setMessage(&#34;Image: {0}&#34;.format(current_filename))

        current_viewer = self.image_viewers[first_active_window]
        if self.save_image_clipboard:
            print(&#34;set save image to clipboard&#34;)
            current_viewer.set_clipboard(self.clip, True)
        current_viewer.set_active(True)
        current_viewer.image_name = self.output_label_current_image
        current_viewer.set_image(current_image)
        if self.save_image_clipboard:
            print(&#34;end save image to clipboard&#34;)
            current_viewer.set_clipboard(None, False)

        # print(f&#34;ref {self.output_label_reference_image}&#34;)
        if self.output_label_reference_image==self.output_label_current_image:
            reference_image = current_image
        else:
            reference_image = self.get_output_image(self.output_label_reference_image)

        if self.nb_viewers_used &gt;= 2:
            prev_n = first_active_window
            for n in range(1, self.nb_viewers_used):
                n1 = (first_active_window + n) % self.nb_viewers_used
                viewer = self.image_viewers[n1]
                # viewer image has already been defined
                # try to update corresponding images in row
                try:
                    viewer_image = self.get_output_image(viewer.image_name)
                except Exception as e:
                    print(&#34;Error: failed to get image {}: {}&#34;.format(viewer.image_name, e))
                    viewer.set_image(current_image)
                else:
                    viewer.set_image(viewer_image)

                # set reference image
                viewer.set_image_ref(reference_image)

                self.image_viewers[prev_n].set_synchronize(viewer)
                prev_n = n1
            # Create a synchronization loop
            if prev_n != first_active_window:
                self.image_viewers[prev_n].set_synchronize(self.image_viewers[first_active_window])

        # Be sure to show the required viewers
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewers[n]
            # print(f&#34;show viewer {n}&#34;)
            # Note: calling show in any case seems to avoid double calls to paint event that update() triggers
            # viewer.show()
            if viewer.isHidden():
                # print(f&#34;show viewer {n}&#34;)
                viewer.show()
            else:
                # print(f&#34;update viewer {n}&#34;)
                viewer.update()


        # self.image_scroll_area.adjustSize()
        # if self.show_timing():
        print(f&#34; Update image took {(get_time() - update_image_start)*1000:0.0f} ms&#34;)

    def set_number_of_viewers(self, nb_viewers: int = 1, max_columns : int = 0) -&gt; None:
        self.print_log(&#34;*** set_number_of_viewers()&#34;)

        # 1. remove current viewers from grid layout
        # self.viewer_grid_layout.hide()
        for v in self.image_viewers:
            v.hide()
            self.viewer_grid_layout.removeWidget(v)

        self.nb_viewers_used : int = nb_viewers
        print(f&#34;max_columns = {max_columns}&#34;)
        if max_columns&gt;0:
            row_length = min(self.nb_viewers_used, max_columns)
            col_length = int(math.ceil(self.nb_viewers_used / row_length))
        else:
            # Find best configuration to fill the space based on image size and widget size?
            col_length = int(math.sqrt(self.nb_viewers_used))
            row_length = int(math.ceil(self.nb_viewers_used / col_length))
        self.print_log(&#39;col_length = {} row_length = {}&#39;.format(col_length, row_length))
        # be sure to have enough image viewers allocated
        while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)

        self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]

        for n in range(self.nb_viewers_used):
            self.viewer_grid_layout.addWidget(self.image_viewers[n], int(n / float(row_length)), n % row_length)
            self.image_viewers[n].hide()

        # for n in range(self.nb_viewers_used):
        #     print(&#34;Viewer {} size {}&#34;.format(n, (self.image_viewers[n].width(), self.image_viewers[n].height())))

    def set_number_of_viewers_callback(self):
        self.set_number_of_viewers()
        self.viewer_grid_layout.update()
        self.update_image()

    def keyReleaseEvent(self, event):
        if type(event) == QtGui.QKeyEvent:
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
            if modifiers &amp; (QtCore.Qt.AltModifier | QtCore.Qt.ControlModifier):
                event.accept()
            # else:
            #     try:
            #         # reset reference image
            #         if self.output_label_current_image != self.output_label_reference_image:
            #             self.update_image(self.output_label_reference_image)
            #     except Exception as e:
            #         print(&#34; Error: {}&#34;.format(e))

    def find_in_layout(self, layout: QtWidgets.QLayout) -&gt; Optional[QtWidgets.QLayout]:
        &#34;&#34;&#34; Search Recursivement in Layouts for the current widget

        Args:
            layout (QtWidgets.QLayout): input layout for search

        Returns:
            layout containing the current widget or None if not found
        &#34;&#34;&#34;
        print(&#34;find_in_layout()&#34;)
        if layout.indexOf(self) != -1: return layout
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item.widget() == self: return layout
            if (l := item.layout()) and (found:=self.find_in_layout(l)): return l
        print(&#34;find_in_layout() return None&#34;)
        return None

    def toggle_fullscreen(self, event):
        print(f&#34;toggle_fullscreen&#34;)
        if not issubclass(self.__class__,QtWidgets.QWidget):
            print(f&#34;Cannot use toggle_fullscreen on a class that is not a QWidget&#34;)
            return
        # Should be inside a layout
        if self.before_max_parent is None:
            print(f&#34;self.parent() is not None {self.parent() is not None}&#34;)
            print(f&#34;self.parent().layout() {self.parent().layout()} &#34;)
            if self.parent() is not None and (playout := self.parent().layout()) is not None:
                if self.find_in_layout(playout):
                    self.before_max_parent = self.parent()
                    self.replacing_widget = QtWidgets.QWidget(self.before_max_parent)
                    self.parent().layout().replaceWidget(self, self.replacing_widget)
                    # We need to go up from the parent widget to the main window to get its geometry
                    # so that the fullscreen is display on the same monitor
                    toplevel_parent : Optional[QtWidgets.QWidget] = self.parentWidget()
                    while toplevel_parent.parentWidget(): toplevel_parent = toplevel_parent.parentWidget()
                    self.setParent(None)
                    if toplevel_parent: self.setGeometry(toplevel_parent.geometry())
                    self.showFullScreen()
                    event.accept()
                    return
        if self.before_max_parent is not None:
            self.setParent(self.before_max_parent)
            self.parent().layout().replaceWidget(self.replacing_widget, self)
            self.replacing_widget = self.before_max_parent = None
            # self.resize(self.before_max_size)
            self.show()
            self.parent().update()
            self.setFocus()
            event.accept()
            return



    def keyPressEvent(self, event):
        if type(event) == QtGui.QKeyEvent:
            # print(&#34;key is &#34;, event.key())
            self.print_log(f&#34; QKeySequence() {QtGui.QKeySequence(event.key()).toString()}&#34;)
            # print( QtGui.QKeySequence(event.key()).toString())
            # print(f&#34; capslock: {event.getModifierState(&#39;CapsLock&#39;)}&#34;)
            if self.show_trace():
                print(&#34;key is &#34;, event.key())
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            # F1: open help in browser
            if event.key() == QtCore.Qt.Key_F1:
                import qimview
                mb = QtWidgets.QMessageBox(self)
                mb.setWindowTitle(f&#34;qimview {qimview.__version__}: MultiView help&#34;)
                mb.setTextFormat(QtCore.Qt.TextFormat.RichText)
                mb.setText(
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki&#39;&gt;qimview&lt;/a&gt;&lt;br&gt;&#34;
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/4.-Multi%E2%80%90image-viewer&#39;&gt;MultiImage Viewer&lt;/a&gt;&lt;br&gt;&#34;
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/3.-Image-Viewers&#39;&gt;Image Viewer&lt;/a&gt;&#34;)
                mb.exec()
                event.accept()
                return

            # F5: reload images
            if event.key() == QtCore.Qt.Key_F5:
                self.update_image(reload=True)
                event.accept()
                return

            if event.key() == QtCore.Qt.Key_F11:
                # Should be inside a layout
                print(&#34;MultiView F11 pressed&#34;)
                self.toggle_fullscreen(event)
                return

            # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
            if modifiers &amp; QtCore.Qt.AltModifier:
                for n in range(len(self.image_list)):
                    if self.image_list[n] is not None:
                        if event.key() == QtCore.Qt.Key_0 + n:
                            if self.output_label_current_image != self.image_list[n]:
                                # with Alt+Ctrl, change reference image
                                # if modifiers &amp; QtCore.Qt.ControlModifier:
                                #     self.set_reference_label(self.image_list[n])
                                self.update_image(self.image_list[n])
                                self.setFocus()
                                return
                event.accept()
                return

            if event.modifiers() &amp; QtCore.Qt.ControlModifier:
                # allow to switch between images by pressing Ctrl+&#39;image position&#39; (Ctrl+0, Ctrl+1, etc)
                for n in range(len(self.image_list)):
                    if self.image_list[n] != &#39;none&#39;:
                        if event.key() == QtCore.Qt.Key_0 + n:
                            if self.output_label_current_image != self.image_list[n]:
                                self.set_reference_label(self.image_list[n], update_viewers=True)
                                self.update_image()
                                event.accept()
                                return
                return
            # print(f&#34;event.modifiers {event.modifiers()}&#34;)
            # if not event.modifiers():
            for n in range(1, 10):
                if event.key() == QtCore.Qt.Key_0 + n:
                    self.set_number_of_viewers(n)
                    self.viewer_grid_layout.update()
                    self.update_image()
                    self.setFocus()
                    event.accept()
                    return

            if event.key() == QtCore.Qt.Key_Up:
                if self.key_up_callback is not None:
                    self.key_up_callback()
                event.accept()
                return

            if event.key() == QtCore.Qt.Key_Down:
                if self.key_down_callback is not None:
                    self.key_down_callback()
                event.accept()
                return

            nb_images = len(self.image_list)
            if event.key() == QtCore.Qt.Key_Left:
                for n in range(nb_images):
                    if self.output_label_current_image == self.image_list[n]:
                        print(f&#34;setting new image index {(n+nb_images-1)%nb_images}&#34;)
                        self.update_image(self.image_list[(n+nb_images-1)%nb_images])
                        event.accept()
                        return

            if event.key() == QtCore.Qt.Key_Right:
                for n in range(nb_images):
                    if self.output_label_current_image == self.image_list[n]:
                        print(f&#34;setting new image index {(n+nb_images+1)%nb_images}&#34;)
                        self.update_image(self.image_list[(n+1)%nb_images])
                        event.accept()
                        return
                
            # G: display number of columns
            if event.key() == QtCore.Qt.Key_G:
                self.max_columns = int ((self.max_columns + 1) % self.nb_viewers_used + 1)
                self.set_number_of_viewers(self.nb_viewers_used, max_columns=self.max_columns)
                self.update_image(reload=True)
                self.setFocus()
                event.accept()
                return

        else:
            event.ignore()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PySide6.QtWidgets.QWidget</li>
<li>PySide6.QtCore.QObject</li>
<li>PySide6.QtGui.QPaintDevice</li>
<li>Shiboken.Object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qimview.image_viewers.multi_view.MultiView.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qimview.image_viewers.multi_view.MultiView.add_context_menu"><code class="name flex">
<span>def <span class="ident">add_context_menu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_context_menu(self):
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.show_context_menu)
    self._context_menu = QtWidgets.QMenu()
    self.viewer_modes = {}
    for v in ViewerType:
        self.viewer_modes[v.name] = v
    self._default_viewer_mode = ViewerType.QT_VIEWER.name
    self.viewer_mode_selection = MenuSelection(&#34;Viewer mode&#34;, 
        self._context_menu, self.viewer_modes, self._default_viewer_mode, self.update_viewer_mode)
    self._context_menu.addSeparator()
    action = self._context_menu.addAction(&#34;Reset viewers&#34;)
    action.triggered.connect(self.reset_viewers)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.cache_read_images"><code class="name flex">
<span>def <span class="ident">cache_read_images</span></span>(<span>self, image_filenames: List[str], reload: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Read the list of images into the cache, with option to reload them from disk</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image_filenames</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>list of image filenames</dd>
<dt><strong><code>reload</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>reload removes first the images from the ImageCache
before adding them. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_read_images(self, image_filenames: List[str], reload: bool =False) -&gt; None:
    &#34;&#34;&#34; Read the list of images into the cache, with option to reload them from disk

    Args:
        image_filenames (List[str]): list of image filenames
        reload (bool, optional): reload removes first the images from the ImageCache 
            before adding them. Defaults to False.
    &#34;&#34;&#34;        
    # print(f&#34;cache_read_images({image_filenames}) &#34;)
    image_transform = None
    if reload:
        for f in image_filenames:
            self.cache.remove(f)
    self.cache.add_images(image_filenames, self.read_size, verbose=False, use_RGB=not self.use_opengl,
                         image_transform=image_transform)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.check_verbosity"><code class="name flex">
<span>def <span class="ident">check_verbosity</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_verbosity(self, flag):
    return self.verbosity &amp; flag</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.clear_buttons"><code class="name flex">
<span>def <span class="ident">clear_buttons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_buttons(self):
    if self.button_layout is not None:
        # start clearing the layout
        # for i in range(self.button_layout.count()): self.button_layout.itemAt(i).widget().close()
        self.print_log(f&#34;MultiView.clear_buttons() {self.image_list}&#34;)
        for image_name in reversed(self.image_list):
            if image_name in self.label:
                self.button_layout.removeWidget(self.label[image_name])
                self.label[image_name].close()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.create_buttons"><code class="name flex">
<span>def <span class="ident">create_buttons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_buttons(self):
    if self.button_layout is not None:
        max_grid_columns = 10
        idx = 0
        for image_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if image_name != &#39;none&#39;:
                self.button_layout.addWidget(self.label[image_name], idx // max_grid_columns, idx % max_grid_columns)
                idx += 1</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.find_in_layout"><code class="name flex">
<span>def <span class="ident">find_in_layout</span></span>(<span>self, layout: PySide6.QtWidgets.QLayout) ‑> Optional[PySide6.QtWidgets.QLayout]</span>
</code></dt>
<dd>
<div class="desc"><p>Search Recursivement in Layouts for the current widget</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>QtWidgets.QLayout</code></dt>
<dd>input layout for search</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>layout containing the current widget or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_in_layout(self, layout: QtWidgets.QLayout) -&gt; Optional[QtWidgets.QLayout]:
    &#34;&#34;&#34; Search Recursivement in Layouts for the current widget

    Args:
        layout (QtWidgets.QLayout): input layout for search

    Returns:
        layout containing the current widget or None if not found
    &#34;&#34;&#34;
    print(&#34;find_in_layout()&#34;)
    if layout.indexOf(self) != -1: return layout
    for i in range(layout.count()):
        item = layout.itemAt(i)
        if item.widget() == self: return layout
        if (l := item.layout()) and (found:=self.find_in_layout(l)): return l
    print(&#34;find_in_layout() return None&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.get_output_image"><code class="name flex">
<span>def <span class="ident">get_output_image</span></span>(<span>self, im_string_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the image with given label in the current row
if not in cache reads it and add it to the cache
:param im_string_id: string that identifies the image to display
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_image(self, im_string_id):
    &#34;&#34;&#34;
    Search for the image with given label in the current row
    if not in cache reads it and add it to the cache
    :param im_string_id: string that identifies the image to display
    :return:
    &#34;&#34;&#34;
    # print(f&#34;get_output_image({im_string_id}) &#34;)
    start = get_time()

    image_filename = self.image_dict[im_string_id]
    image_transform = None
    self.print_log(f&#34;MultiView.get_output_image() image_filename:{image_filename}&#34;)

    image_data, _ = self.cache.get_image(image_filename, self.read_size, verbose=self.show_timing_detailed(),
                                         use_RGB=not self.use_opengl, image_transform=image_transform)

    if image_data is not None:
        self.output_image_label[im_string_id] = image_filename
        output_image = image_data
    else:
        print(f&#34;failed to get image {im_string_id}: {image_filename}&#34;)
        return None

    if self.show_timing_detailed():
        print(f&#34; get_output_image took {int((get_time() - start)*1000+0.5)} ms&#34;.format)

    # force image bayer information if selected from menu
    res = output_image
    set_bayer = self.raw_bayer[self.current_raw_bayer]
    if res.channels in [ImageFormat.CH_BGGR, ImageFormat.CH_GBRG, ImageFormat.CH_GRBG, ImageFormat.CH_RGGB] and set_bayer is not None:
        print(f&#34;Setting bayer {set_bayer}&#34;)
        res.channels = set_bayer

    return res</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.keyPressEvent"><code class="name flex">
<span>def <span class="ident">keyPressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>keyPressEvent(self, event: PySide6.QtGui.QKeyEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyPressEvent(self, event):
    if type(event) == QtGui.QKeyEvent:
        # print(&#34;key is &#34;, event.key())
        self.print_log(f&#34; QKeySequence() {QtGui.QKeySequence(event.key()).toString()}&#34;)
        # print( QtGui.QKeySequence(event.key()).toString())
        # print(f&#34; capslock: {event.getModifierState(&#39;CapsLock&#39;)}&#34;)
        if self.show_trace():
            print(&#34;key is &#34;, event.key())
        modifiers = QtWidgets.QApplication.keyboardModifiers()
        # F1: open help in browser
        if event.key() == QtCore.Qt.Key_F1:
            import qimview
            mb = QtWidgets.QMessageBox(self)
            mb.setWindowTitle(f&#34;qimview {qimview.__version__}: MultiView help&#34;)
            mb.setTextFormat(QtCore.Qt.TextFormat.RichText)
            mb.setText(
                &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki&#39;&gt;qimview&lt;/a&gt;&lt;br&gt;&#34;
                &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/4.-Multi%E2%80%90image-viewer&#39;&gt;MultiImage Viewer&lt;/a&gt;&lt;br&gt;&#34;
                &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/3.-Image-Viewers&#39;&gt;Image Viewer&lt;/a&gt;&#34;)
            mb.exec()
            event.accept()
            return

        # F5: reload images
        if event.key() == QtCore.Qt.Key_F5:
            self.update_image(reload=True)
            event.accept()
            return

        if event.key() == QtCore.Qt.Key_F11:
            # Should be inside a layout
            print(&#34;MultiView F11 pressed&#34;)
            self.toggle_fullscreen(event)
            return

        # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
        if modifiers &amp; QtCore.Qt.AltModifier:
            for n in range(len(self.image_list)):
                if self.image_list[n] is not None:
                    if event.key() == QtCore.Qt.Key_0 + n:
                        if self.output_label_current_image != self.image_list[n]:
                            # with Alt+Ctrl, change reference image
                            # if modifiers &amp; QtCore.Qt.ControlModifier:
                            #     self.set_reference_label(self.image_list[n])
                            self.update_image(self.image_list[n])
                            self.setFocus()
                            return
            event.accept()
            return

        if event.modifiers() &amp; QtCore.Qt.ControlModifier:
            # allow to switch between images by pressing Ctrl+&#39;image position&#39; (Ctrl+0, Ctrl+1, etc)
            for n in range(len(self.image_list)):
                if self.image_list[n] != &#39;none&#39;:
                    if event.key() == QtCore.Qt.Key_0 + n:
                        if self.output_label_current_image != self.image_list[n]:
                            self.set_reference_label(self.image_list[n], update_viewers=True)
                            self.update_image()
                            event.accept()
                            return
            return
        # print(f&#34;event.modifiers {event.modifiers()}&#34;)
        # if not event.modifiers():
        for n in range(1, 10):
            if event.key() == QtCore.Qt.Key_0 + n:
                self.set_number_of_viewers(n)
                self.viewer_grid_layout.update()
                self.update_image()
                self.setFocus()
                event.accept()
                return

        if event.key() == QtCore.Qt.Key_Up:
            if self.key_up_callback is not None:
                self.key_up_callback()
            event.accept()
            return

        if event.key() == QtCore.Qt.Key_Down:
            if self.key_down_callback is not None:
                self.key_down_callback()
            event.accept()
            return

        nb_images = len(self.image_list)
        if event.key() == QtCore.Qt.Key_Left:
            for n in range(nb_images):
                if self.output_label_current_image == self.image_list[n]:
                    print(f&#34;setting new image index {(n+nb_images-1)%nb_images}&#34;)
                    self.update_image(self.image_list[(n+nb_images-1)%nb_images])
                    event.accept()
                    return

        if event.key() == QtCore.Qt.Key_Right:
            for n in range(nb_images):
                if self.output_label_current_image == self.image_list[n]:
                    print(f&#34;setting new image index {(n+nb_images+1)%nb_images}&#34;)
                    self.update_image(self.image_list[(n+1)%nb_images])
                    event.accept()
                    return
            
        # G: display number of columns
        if event.key() == QtCore.Qt.Key_G:
            self.max_columns = int ((self.max_columns + 1) % self.nb_viewers_used + 1)
            self.set_number_of_viewers(self.nb_viewers_used, max_columns=self.max_columns)
            self.update_image(reload=True)
            self.setFocus()
            event.accept()
            return

    else:
        event.ignore()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.keyReleaseEvent"><code class="name flex">
<span>def <span class="ident">keyReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>keyReleaseEvent(self, event: PySide6.QtGui.QKeyEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyReleaseEvent(self, event):
    if type(event) == QtGui.QKeyEvent:
        modifiers = QtWidgets.QApplication.keyboardModifiers()
        # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
        if modifiers &amp; (QtCore.Qt.AltModifier | QtCore.Qt.ControlModifier):
            event.accept()
        # else:
        #     try:
        #         # reset reference image
        #         if self.output_label_current_image != self.output_label_reference_image:
        #             self.update_image(self.output_label_reference_image)
        #     except Exception as e:
        #         print(&#34; Error: {}&#34;.format(e))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.layout_buttons"><code class="name flex">
<span>def <span class="ident">layout_buttons</span></span>(<span>self, vertical_layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layout_buttons(self, vertical_layout):
    self.button_widget = QtWidgets.QWidget(self)
    self.button_layout = QtWidgets.QGridLayout()
    self.button_layout.setHorizontalSpacing(0)
    self.button_layout.setVerticalSpacing(0)
    # button_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
    self.create_buttons()
    vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
    # vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetNoConstraint)
    self.button_widget.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
    self.button_widget.setLayout(self.button_layout)
    vertical_layout.addWidget(self.button_widget, 0, QtCore.Qt.AlignTop)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.layout_parameters"><code class="name flex">
<span>def <span class="ident">layout_parameters</span></span>(<span>self, parameters_layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layout_parameters(self, parameters_layout):
    # Add Profiles and keep zoom options
    self.display_profiles = QtWidgets.QCheckBox(&#34;Profiles&#34;)
    self.display_profiles.stateChanged.connect(self.toggle_display_profiles)
    self.display_profiles.setChecked(False)
    parameters_layout.addWidget(self.display_profiles)
    self.keep_zoom = QtWidgets.QCheckBox(&#34;Keep zoom&#34;)
    self.keep_zoom.setChecked(False)
    parameters_layout.addWidget(self.keep_zoom)

    # Reset button
    self.reset_button = QtWidgets.QPushButton(&#34;reset&#34;)
    parameters_layout.addWidget(self.reset_button)
    self.reset_button.clicked.connect(self.reset_intensities)

    # Add color difference slider
    self.filter_params_gui.add_imdiff_factor(parameters_layout, self.update_image_intensity_event)

    # --- Saturation adjustment
    self.filter_params_gui.add_saturation(parameters_layout, self.update_image_intensity_event)
    # --- Black point adjustment
    self.filter_params_gui.add_blackpoint(parameters_layout, self.update_image_intensity_event)
    # --- white point adjustment
    self.filter_params_gui.add_whitepoint(parameters_layout, self.update_image_intensity_event)
    # --- Gamma adjustment
    self.filter_params_gui.add_gamma(parameters_layout, self.update_image_intensity_event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.layout_parameters_2"><code class="name flex">
<span>def <span class="ident">layout_parameters_2</span></span>(<span>self, parameters2_layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layout_parameters_2(self, parameters2_layout):
    # --- G_R adjustment
    self.filter_params_gui.add_g_r(parameters2_layout, self.update_image_intensity_event)
    # --- G_B adjustment
    self.filter_params_gui.add_g_b(parameters2_layout, self.update_image_intensity_event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.make_mouse_double_click"><code class="name flex">
<span>def <span class="ident">make_mouse_double_click</span></span>(<span>self, image_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_mouse_double_click(self, image_name):
    def mouse_double_click(obj, event):
        &#39;&#39;&#39;
        Sets the double clicked label as the reference image
        :param obj:
        :param event:
        &#39;&#39;&#39;
        print(&#39;mouse_double_click {}&#39;.format(image_name))
        obj.output_label_reference_image = image_name
        obj.output_label_current_image = obj.output_label_reference_image
        obj.update_image()

    return types.MethodType(mouse_double_click, self)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.make_mouse_press"><code class="name flex">
<span>def <span class="ident">make_mouse_press</span></span>(<span>self, image_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_mouse_press(self, image_name):
    def mouse_press(obj, event):
        print(&#39;mouse_press&#39;)
        obj.update_image(image_name)

    return types.MethodType(mouse_press, self)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.mouse_release"><code class="name flex">
<span>def <span class="ident">mouse_release</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouse_release(self, event):
    self.update_image(self.output_label_reference_image)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.print_log"><code class="name flex">
<span>def <span class="ident">print_log</span></span>(<span>self, mess)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_log(self, mess):
    if self.verbosity &amp; self.verbosity_LIGHT:
        print(mess)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.reset_intensities"><code class="name flex">
<span>def <span class="ident">reset_intensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_intensities(self):
    self.filter_params_gui.reset_all()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.reset_viewers"><code class="name flex">
<span>def <span class="ident">reset_viewers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_viewers(self):
    for v in self.image_viewers:
        v.hide()
        self.viewer_grid_layout.removeWidget(v)
    self.allocated_image_viewers.clear()
    self.image_viewers.clear()
    # Create viewer instances
    for n in range(self.nb_viewers_used):
        viewer = self.image_viewer_class()
        viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.allocated_image_viewers.append(viewer)
        self.image_viewers.append(viewer)
    self.set_number_of_viewers(self.nb_viewers_used)
    self.viewer_grid_layout.update()
    self.update_image()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.setMessage"><code class="name flex">
<span>def <span class="ident">setMessage</span></span>(<span>self, mess)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMessage(self, mess):
    if self.message_cb is not None:
        self.message_cb(mess)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_cache_memory_bar"><code class="name flex">
<span>def <span class="ident">set_cache_memory_bar</span></span>(<span>self, progress_bar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cache_memory_bar(self, progress_bar):
    self.cache.set_memory_bar(progress_bar)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_images"><code class="name flex">
<span>def <span class="ident">set_images</span></span>(<span>self, images, set_viewers=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_images(self, images, set_viewers=False):
    self.print_log(f&#34;MultiView.set_images() {images}&#34;)
    if images.keys() == self.image_dict.keys():
        self.image_dict = images
        self.update_reference()
    else:
        self.image_dict = images
        self.update_image_buttons()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_key_down_callback"><code class="name flex">
<span>def <span class="ident">set_key_down_callback</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_key_down_callback(self, c):
    self.key_down_callback = c</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_key_up_callback"><code class="name flex">
<span>def <span class="ident">set_key_up_callback</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_key_up_callback(self, c):
    self.key_up_callback = c</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_message_callback"><code class="name flex">
<span>def <span class="ident">set_message_callback</span></span>(<span>self, message_cb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_message_callback(self, message_cb):
    self.message_cb = message_cb</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_number_of_viewers"><code class="name flex">
<span>def <span class="ident">set_number_of_viewers</span></span>(<span>self, nb_viewers: int = 1, max_columns: int = 0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_number_of_viewers(self, nb_viewers: int = 1, max_columns : int = 0) -&gt; None:
    self.print_log(&#34;*** set_number_of_viewers()&#34;)

    # 1. remove current viewers from grid layout
    # self.viewer_grid_layout.hide()
    for v in self.image_viewers:
        v.hide()
        self.viewer_grid_layout.removeWidget(v)

    self.nb_viewers_used : int = nb_viewers
    print(f&#34;max_columns = {max_columns}&#34;)
    if max_columns&gt;0:
        row_length = min(self.nb_viewers_used, max_columns)
        col_length = int(math.ceil(self.nb_viewers_used / row_length))
    else:
        # Find best configuration to fill the space based on image size and widget size?
        col_length = int(math.sqrt(self.nb_viewers_used))
        row_length = int(math.ceil(self.nb_viewers_used / col_length))
    self.print_log(&#39;col_length = {} row_length = {}&#39;.format(col_length, row_length))
    # be sure to have enough image viewers allocated
    while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
        viewer = self.image_viewer_class()
        viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.allocated_image_viewers.append(viewer)

    self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]

    for n in range(self.nb_viewers_used):
        self.viewer_grid_layout.addWidget(self.image_viewers[n], int(n / float(row_length)), n % row_length)
        self.image_viewers[n].hide()

    # for n in range(self.nb_viewers_used):
    #     print(&#34;Viewer {} size {}&#34;.format(n, (self.image_viewers[n].width(), self.image_viewers[n].height())))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_number_of_viewers_callback"><code class="name flex">
<span>def <span class="ident">set_number_of_viewers_callback</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_number_of_viewers_callback(self):
    self.set_number_of_viewers()
    self.viewer_grid_layout.update()
    self.update_image()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_read_size"><code class="name flex">
<span>def <span class="ident">set_read_size</span></span>(<span>self, read_size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_read_size(self, read_size):
    self.read_size = read_size
    # reset cache
    self.cache.reset()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_reference_label"><code class="name flex">
<span>def <span class="ident">set_reference_label</span></span>(<span>self, ref: str, update_viewers=False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_reference_label(self, ref: str, update_viewers=False) -&gt; None:
    try:
        if ref is not None:
            if ref!=self.output_label_reference_image:
                self.output_label_reference_image = ref
                if update_viewers:
                    self.update_reference()
    except Exception as e:
        print(f&#39; Failed to set reference label {e}&#39;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_verbosity"><code class="name flex">
<span>def <span class="ident">set_verbosity</span></span>(<span>self, flag, enable=True)</span>
</code></dt>
<dd>
<div class="desc"><p>:param v: verbosity flags
:param b: boolean to enable or disable flag
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_verbosity(self, flag, enable=True):
    &#34;&#34;&#34;
    :param v: verbosity flags
    :param b: boolean to enable or disable flag
    :return:
    &#34;&#34;&#34;
    if enable:
        self.verbosity = self.verbosity | flag
    else:
        self.verbosity = self.verbosity &amp; ~flag</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.set_viewer_images"><code class="name flex">
<span>def <span class="ident">set_viewer_images</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set viewer images based on self.image_dict.keys()
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_viewer_images(self):
    &#34;&#34;&#34;
    Set viewer images based on self.image_dict.keys()
    :return:
    &#34;&#34;&#34;
    # if set_viewers, we force the viewer layout and images based on the list
    # be sure to have enough image viewers allocated
    while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
        viewer = self.image_viewer_class()
        viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.allocated_image_viewers.append(viewer)
    self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]
    image_names = list(self.image_dict.keys())
    for n in range(self.nb_viewers_used):
        if n &lt; len(image_names):
            self.image_viewers[n].image_name = image_names[n]
        else:
            self.image_viewers[n].image_name = image_names[len(image_names)-1]</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.show_context_menu"><code class="name flex">
<span>def <span class="ident">show_context_menu</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_context_menu(self, pos):
    # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
    self._context_menu.show()
    self._context_menu.popup( self.mapToGlobal(pos) )</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.show_timing"><code class="name flex">
<span>def <span class="ident">show_timing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_timing(self):
    return self.check_verbosity(self.verbosity_TIMING) or self.check_verbosity(self.verbosity_TIMING_DETAILED)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.show_timing_detailed"><code class="name flex">
<span>def <span class="ident">show_timing_detailed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_timing_detailed(self):
    return self.check_verbosity(self.verbosity_TIMING_DETAILED)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.show_trace"><code class="name flex">
<span>def <span class="ident">show_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_trace(self):
    return self.check_verbosity(self.verbosity_TRACE)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.toggle_display_profiles"><code class="name flex">
<span>def <span class="ident">toggle_display_profiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_display_profiles(self):
    self.figures_widget.setVisible(self.display_profiles.isChecked())
    self.update_image()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.toggle_fullscreen"><code class="name flex">
<span>def <span class="ident">toggle_fullscreen</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_fullscreen(self, event):
    print(f&#34;toggle_fullscreen&#34;)
    if not issubclass(self.__class__,QtWidgets.QWidget):
        print(f&#34;Cannot use toggle_fullscreen on a class that is not a QWidget&#34;)
        return
    # Should be inside a layout
    if self.before_max_parent is None:
        print(f&#34;self.parent() is not None {self.parent() is not None}&#34;)
        print(f&#34;self.parent().layout() {self.parent().layout()} &#34;)
        if self.parent() is not None and (playout := self.parent().layout()) is not None:
            if self.find_in_layout(playout):
                self.before_max_parent = self.parent()
                self.replacing_widget = QtWidgets.QWidget(self.before_max_parent)
                self.parent().layout().replaceWidget(self, self.replacing_widget)
                # We need to go up from the parent widget to the main window to get its geometry
                # so that the fullscreen is display on the same monitor
                toplevel_parent : Optional[QtWidgets.QWidget] = self.parentWidget()
                while toplevel_parent.parentWidget(): toplevel_parent = toplevel_parent.parentWidget()
                self.setParent(None)
                if toplevel_parent: self.setGeometry(toplevel_parent.geometry())
                self.showFullScreen()
                event.accept()
                return
    if self.before_max_parent is not None:
        self.setParent(self.before_max_parent)
        self.parent().layout().replaceWidget(self.replacing_widget, self)
        self.replacing_widget = self.before_max_parent = None
        # self.resize(self.before_max_size)
        self.show()
        self.parent().update()
        self.setFocus()
        event.accept()
        return</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_image"><code class="name flex">
<span>def <span class="ident">update_image</span></span>(<span>self, image_name=None, reload=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the variable self.output_label_current_image
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image(self, image_name=None, reload=False):
    &#34;&#34;&#34;
    Uses the variable self.output_label_current_image
    :return:
    &#34;&#34;&#34;
    self.print_log(&#39;update_image {} current: {}&#39;.format(image_name, self.output_label_current_image))
    update_image_start = get_time()

    # Define the current selected image
    if image_name is not None:
        self.output_label_current_image = image_name
    if self.output_label_current_image == &#34;&#34;:
        return

    if self.image_dict[self.output_label_current_image] is None:
        print(&#34; No image filename for current image&#34;)
        return

    self.update_label_fonts()

    # find first active window
    first_active_window = 0
    for n in range(self.nb_viewers_used):
        self.image_viewers[n].display_timing = self.show_timing()&gt;0
        if self.image_viewers[n].is_active():
            first_active_window = n
            break

    # Read images in parallel to improve preformances
    # list all required image filenames
    # set all viewers image names (labels)
    image_filenames = [self.image_dict[self.output_label_current_image]]
    # define image associated to each used viewer and add it to the list of images to get
    for n in range(self.nb_viewers_used):
        viewer : ImageViewer = self.image_viewers[n]
        # Set active only the first active window
        viewer.set_active(n == first_active_window)
        if viewer.get_image() is None:
            if n &lt; len(self.image_list):
                viewer.image_name = self.image_list[n]
                image_filenames.append(self.image_dict[self.image_list[n]])
            else:
                viewer.image_name = self.output_label_current_image
        else:
            # image_name should belong to image_dict
            if viewer.image_name in self.image_dict:
                image_filenames.append(self.image_dict[viewer.image_name])
            else:
                viewer.image_name = self.output_label_current_image

    # remove duplicates
    image_filenames = list(set(image_filenames))
    # print(f&#34;image filenames {image_filenames}&#34;)
    self.cache_read_images(image_filenames, reload=reload)

    try:
        current_image = self.get_output_image(self.output_label_current_image)
        if current_image is None:
            return
    except Exception as e:
        print(&#34;Error: failed to get image {}: {}&#34;.format(self.output_label_current_image, e))
        return

    # print(f&#34;cur {self.output_label_current_image}&#34;)
    current_filename = self.output_image_label[self.output_label_current_image]

    if self.show_timing_detailed():
        time_spent = get_time() - update_image_start

    self.setMessage(&#34;Image: {0}&#34;.format(current_filename))

    current_viewer = self.image_viewers[first_active_window]
    if self.save_image_clipboard:
        print(&#34;set save image to clipboard&#34;)
        current_viewer.set_clipboard(self.clip, True)
    current_viewer.set_active(True)
    current_viewer.image_name = self.output_label_current_image
    current_viewer.set_image(current_image)
    if self.save_image_clipboard:
        print(&#34;end save image to clipboard&#34;)
        current_viewer.set_clipboard(None, False)

    # print(f&#34;ref {self.output_label_reference_image}&#34;)
    if self.output_label_reference_image==self.output_label_current_image:
        reference_image = current_image
    else:
        reference_image = self.get_output_image(self.output_label_reference_image)

    if self.nb_viewers_used &gt;= 2:
        prev_n = first_active_window
        for n in range(1, self.nb_viewers_used):
            n1 = (first_active_window + n) % self.nb_viewers_used
            viewer = self.image_viewers[n1]
            # viewer image has already been defined
            # try to update corresponding images in row
            try:
                viewer_image = self.get_output_image(viewer.image_name)
            except Exception as e:
                print(&#34;Error: failed to get image {}: {}&#34;.format(viewer.image_name, e))
                viewer.set_image(current_image)
            else:
                viewer.set_image(viewer_image)

            # set reference image
            viewer.set_image_ref(reference_image)

            self.image_viewers[prev_n].set_synchronize(viewer)
            prev_n = n1
        # Create a synchronization loop
        if prev_n != first_active_window:
            self.image_viewers[prev_n].set_synchronize(self.image_viewers[first_active_window])

    # Be sure to show the required viewers
    for n in range(self.nb_viewers_used):
        viewer = self.image_viewers[n]
        # print(f&#34;show viewer {n}&#34;)
        # Note: calling show in any case seems to avoid double calls to paint event that update() triggers
        # viewer.show()
        if viewer.isHidden():
            # print(f&#34;show viewer {n}&#34;)
            viewer.show()
        else:
            # print(f&#34;update viewer {n}&#34;)
            viewer.update()


    # self.image_scroll_area.adjustSize()
    # if self.show_timing():
    print(f&#34; Update image took {(get_time() - update_image_start)*1000:0.0f} ms&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_image_buttons"><code class="name flex">
<span>def <span class="ident">update_image_buttons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image_buttons(self):
    # choose image to display
    self.clear_buttons()
    self.image_list = list(self.image_dict.keys())
    self.print_log(&#34;MultiView.update_image_buttons() {}&#34;.format(self.image_list))
    self.label = dict()
    for image_name in self.image_list:
        # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
        if image_name != &#39;none&#39;:
            self.label[image_name] = MVLabel(image_name, self)
            self.label[image_name].setFrameShape(QtWidgets.QFrame.Panel)
            self.label[image_name].setFrameShadow(QtWidgets.QFrame.Sunken)
            # self.label[image_name].setLineWidth(3)
            self.label[image_name].setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
            # self.label[image_name].setFixedHeight(40)
            self.label[image_name].mousePressEvent = self.make_mouse_press(image_name)
            self.label[image_name].mouseReleaseEvent = self.mouse_release
            self.label[image_name].mouseDoubleClickEvent = self.make_mouse_double_click(image_name)
    self.create_buttons()

    # the crop area can be changed using the mouse wheel
    self.output_label_crop = (0., 0., 1., 1.)

    if len(self.image_list)&gt;0:
        self.output_label_current_image = self.image_list[0]
        self.set_reference_label(self.image_list[0], update_viewers=True)
    else:
        self.output_label_current_image = &#39;&#39;
        self.output_label_reference_image = &#39;&#39;</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_image_intensity_event"><code class="name flex">
<span>def <span class="ident">update_image_intensity_event</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image_intensity_event(self):
    self.update_image_parameters()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_image_parameters"><code class="name flex">
<span>def <span class="ident">update_image_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the variable self.output_label_current_image
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image_parameters(self):
    &#39;&#39;&#39;
    Uses the variable self.output_label_current_image
    :return:
    &#39;&#39;&#39;
    self.print_log(&#39;update_image_parameters&#39;)
    update_start = get_time()

    for n in range(self.nb_viewers_used):
        self.image_viewers[n].filter_params.copy_from(self.filter_params)
        self.image_viewers[n].update()

    if self.show_timing():
        time_spent = get_time() - update_start
        self.print_log(&#34; Update image took {0:0.3f} sec.&#34;.format(time_spent))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_label_fonts"><code class="name flex">
<span>def <span class="ident">update_label_fonts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_label_fonts(self):
    # Update selected image label, we could do it later too
    for im_name in self.image_list:
        # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
        if im_name != &#39;none&#39;:
            is_bold      = im_name == self.output_label_current_image
            is_underline = im_name == self.output_label_reference_image
            is_bold |= is_underline
            self.bold_font.setBold(is_bold)
            self.bold_font.setUnderline(is_underline)
            self.bold_font.setPointSize(8)
            self.label[im_name].setFont(self.bold_font)
            self.label[im_name].setWordWrap(True)
        # self.label[im_name].setMaximumWidth(160)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_layout"><code class="name flex">
<span>def <span class="ident">update_layout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_layout(self):
    self.print_log(&#34;update_layout&#34;)
    vertical_layout = QtWidgets.QVBoxLayout()
    self.layout_buttons(vertical_layout)

    # First line of parameter control
    parameters_layout = QtWidgets.QHBoxLayout()
    self.layout_parameters(parameters_layout)
    vertical_layout.addLayout(parameters_layout, 1)

    # Second line of parameter control
    parameters2_layout = QtWidgets.QHBoxLayout()
    self.layout_parameters_2(parameters2_layout)
    vertical_layout.addLayout(parameters2_layout, 1)

    self.viewer_grid_layout = QtWidgets.QGridLayout()
    self.viewer_grid_layout.setHorizontalSpacing(1)
    self.viewer_grid_layout.setVerticalSpacing(1)
    self.set_number_of_viewers(1)
    vertical_layout.addLayout(self.viewer_grid_layout, 1)

    self.figures_widget = QtWidgets.QWidget()
    self.figures_layout = QtWidgets.QHBoxLayout()
    self.figures_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
    # for the moment ignore this
    # self.figures_layout.addWidget(self.value_in_range_canvas)
    # self.figures_widget.setLayout(self.figures_layout)

    vertical_layout.addWidget(self.figures_widget)
    self.toggle_display_profiles()
    self.setLayout(vertical_layout)
    print(&#34;update_layout done&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_reference"><code class="name flex">
<span>def <span class="ident">update_reference</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_reference(self) -&gt; None:
    reference_image = self.get_output_image(self.output_label_reference_image)
    for n in range(self.nb_viewers_used):
        viewer = self.image_viewers[n]
        # set reference image
        viewer.set_image_ref(reference_image)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.multi_view.MultiView.update_viewer_mode"><code class="name flex">
<span>def <span class="ident">update_viewer_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_viewer_mode(self):
    viewer_mode = self.viewer_mode_selection.get_selection_value()
    self.image_viewer_class = self.image_viewer_classes[viewer_mode]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qimview.image_viewers.multi_view.ViewerType"><code class="flex name class">
<span>class <span class="ident">ViewerType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ViewerType(Enum):
    QT_VIEWER             = auto()
    OPENGL_VIEWER         = auto()
    OPENGL_SHADERS_VIEWER = auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qimview.image_viewers.multi_view.ViewerType.OPENGL_SHADERS_VIEWER"><code class="name">var <span class="ident">OPENGL_SHADERS_VIEWER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qimview.image_viewers.multi_view.ViewerType.OPENGL_VIEWER"><code class="name">var <span class="ident">OPENGL_VIEWER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qimview.image_viewers.multi_view.ViewerType.QT_VIEWER"><code class="name">var <span class="ident">QT_VIEWER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qimview.image_viewers" href="index.html">qimview.image_viewers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qimview.image_viewers.multi_view.MultiView" href="#qimview.image_viewers.multi_view.MultiView">MultiView</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.multi_view.MultiView.add_context_menu" href="#qimview.image_viewers.multi_view.MultiView.add_context_menu">add_context_menu</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.cache_read_images" href="#qimview.image_viewers.multi_view.MultiView.cache_read_images">cache_read_images</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.check_verbosity" href="#qimview.image_viewers.multi_view.MultiView.check_verbosity">check_verbosity</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.clear_buttons" href="#qimview.image_viewers.multi_view.MultiView.clear_buttons">clear_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.create_buttons" href="#qimview.image_viewers.multi_view.MultiView.create_buttons">create_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.find_in_layout" href="#qimview.image_viewers.multi_view.MultiView.find_in_layout">find_in_layout</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.get_output_image" href="#qimview.image_viewers.multi_view.MultiView.get_output_image">get_output_image</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.keyPressEvent" href="#qimview.image_viewers.multi_view.MultiView.keyPressEvent">keyPressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.keyReleaseEvent" href="#qimview.image_viewers.multi_view.MultiView.keyReleaseEvent">keyReleaseEvent</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.layout_buttons" href="#qimview.image_viewers.multi_view.MultiView.layout_buttons">layout_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.layout_parameters" href="#qimview.image_viewers.multi_view.MultiView.layout_parameters">layout_parameters</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.layout_parameters_2" href="#qimview.image_viewers.multi_view.MultiView.layout_parameters_2">layout_parameters_2</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.make_mouse_double_click" href="#qimview.image_viewers.multi_view.MultiView.make_mouse_double_click">make_mouse_double_click</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.make_mouse_press" href="#qimview.image_viewers.multi_view.MultiView.make_mouse_press">make_mouse_press</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.mouse_release" href="#qimview.image_viewers.multi_view.MultiView.mouse_release">mouse_release</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.print_log" href="#qimview.image_viewers.multi_view.MultiView.print_log">print_log</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.reset_intensities" href="#qimview.image_viewers.multi_view.MultiView.reset_intensities">reset_intensities</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.reset_viewers" href="#qimview.image_viewers.multi_view.MultiView.reset_viewers">reset_viewers</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.setMessage" href="#qimview.image_viewers.multi_view.MultiView.setMessage">setMessage</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_cache_memory_bar" href="#qimview.image_viewers.multi_view.MultiView.set_cache_memory_bar">set_cache_memory_bar</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_images" href="#qimview.image_viewers.multi_view.MultiView.set_images">set_images</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_key_down_callback" href="#qimview.image_viewers.multi_view.MultiView.set_key_down_callback">set_key_down_callback</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_key_up_callback" href="#qimview.image_viewers.multi_view.MultiView.set_key_up_callback">set_key_up_callback</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_message_callback" href="#qimview.image_viewers.multi_view.MultiView.set_message_callback">set_message_callback</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_number_of_viewers" href="#qimview.image_viewers.multi_view.MultiView.set_number_of_viewers">set_number_of_viewers</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_number_of_viewers_callback" href="#qimview.image_viewers.multi_view.MultiView.set_number_of_viewers_callback">set_number_of_viewers_callback</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_read_size" href="#qimview.image_viewers.multi_view.MultiView.set_read_size">set_read_size</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_reference_label" href="#qimview.image_viewers.multi_view.MultiView.set_reference_label">set_reference_label</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_verbosity" href="#qimview.image_viewers.multi_view.MultiView.set_verbosity">set_verbosity</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.set_viewer_images" href="#qimview.image_viewers.multi_view.MultiView.set_viewer_images">set_viewer_images</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.show_context_menu" href="#qimview.image_viewers.multi_view.MultiView.show_context_menu">show_context_menu</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.show_timing" href="#qimview.image_viewers.multi_view.MultiView.show_timing">show_timing</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.show_timing_detailed" href="#qimview.image_viewers.multi_view.MultiView.show_timing_detailed">show_timing_detailed</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.show_trace" href="#qimview.image_viewers.multi_view.MultiView.show_trace">show_trace</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.staticMetaObject" href="#qimview.image_viewers.multi_view.MultiView.staticMetaObject">staticMetaObject</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.toggle_display_profiles" href="#qimview.image_viewers.multi_view.MultiView.toggle_display_profiles">toggle_display_profiles</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.toggle_fullscreen" href="#qimview.image_viewers.multi_view.MultiView.toggle_fullscreen">toggle_fullscreen</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_image" href="#qimview.image_viewers.multi_view.MultiView.update_image">update_image</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_image_buttons" href="#qimview.image_viewers.multi_view.MultiView.update_image_buttons">update_image_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_image_intensity_event" href="#qimview.image_viewers.multi_view.MultiView.update_image_intensity_event">update_image_intensity_event</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_image_parameters" href="#qimview.image_viewers.multi_view.MultiView.update_image_parameters">update_image_parameters</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_label_fonts" href="#qimview.image_viewers.multi_view.MultiView.update_label_fonts">update_label_fonts</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_layout" href="#qimview.image_viewers.multi_view.MultiView.update_layout">update_layout</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_reference" href="#qimview.image_viewers.multi_view.MultiView.update_reference">update_reference</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.MultiView.update_viewer_mode" href="#qimview.image_viewers.multi_view.MultiView.update_viewer_mode">update_viewer_mode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qimview.image_viewers.multi_view.ViewerType" href="#qimview.image_viewers.multi_view.ViewerType">ViewerType</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.multi_view.ViewerType.OPENGL_SHADERS_VIEWER" href="#qimview.image_viewers.multi_view.ViewerType.OPENGL_SHADERS_VIEWER">OPENGL_SHADERS_VIEWER</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.ViewerType.OPENGL_VIEWER" href="#qimview.image_viewers.multi_view.ViewerType.OPENGL_VIEWER">OPENGL_VIEWER</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view.ViewerType.QT_VIEWER" href="#qimview.image_viewers.multi_view.ViewerType.QT_VIEWER">QT_VIEWER</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>