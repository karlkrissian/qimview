<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qimview.image_viewers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qimview.image_viewers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Import from the less dependent to the most dependent module
from .image_filter_parameters     import ImageFilterParameters
from .image_filter_parameters_gui import ImageFilterParametersGui
from .qt_image_viewer             import QTImageViewer
from .gl_image_viewer             import GLImageViewer
from .gl_image_viewer_shaders     import GLImageViewerShaders
from .multi_view                  import MultiView, ViewerType

__all__ = [
    &#39;ImageFilterParameters&#39;,
    &#39;ImageFilterParametersGui&#39;,
    &#39;QTImageViewer&#39;,
    &#39;GLImageViewer&#39;,
    &#39;GLImageViewerShaders&#39;,
    &#39;ViewerType&#39;,
    &#39;MultiView&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="qimview.image_viewers.gl_image_viewer" href="gl_image_viewer.html">qimview.image_viewers.gl_image_viewer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qimview.image_viewers.gl_image_viewer_base" href="gl_image_viewer_base.html">qimview.image_viewers.gl_image_viewer_base</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qimview.image_viewers.gl_image_viewer_shaders" href="gl_image_viewer_shaders.html">qimview.image_viewers.gl_image_viewer_shaders</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qimview.image_viewers.image_filter_parameters" href="image_filter_parameters.html">qimview.image_viewers.image_filter_parameters</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qimview.image_viewers.image_filter_parameters_gui" href="image_filter_parameters_gui.html">qimview.image_viewers.image_filter_parameters_gui</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qimview.image_viewers.image_viewer" href="image_viewer.html">qimview.image_viewers.image_viewer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qimview.image_viewers.multi_view" href="multi_view.html">qimview.image_viewers.multi_view</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qimview.image_viewers.qt_image_viewer" href="qt_image_viewer.html">qimview.image_viewers.qt_image_viewer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qimview.image_viewers.GLImageViewer"><code class="flex name class">
<span>class <span class="ident">GLImageViewer</span></span>
<span>(</span><span>parent=None, event_recorder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QOpenGLWidget(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p><strong>init</strong>(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p>Initialize self.
See help(type(self)) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GLImageViewer(GLImageViewerBase):

    def __init__(self, parent=None, event_recorder=None):
        self.event_recorder = event_recorder
        super().__init__(parent)
        self.setAutoFillBackground(False)
        self.textureID  = None
        self.tex_width, self.tex_height = 0, 0
        self.opengl_debug = True
        self.trace_calls  = False

    def initializeGL(self):
        &#34;&#34;&#34;Initialize OpenGL, VBOs, upload data on the GPU, etc.
        &#34;&#34;&#34;
        # self.setTexture()
        pass

    def viewer_update(self):
        self.update()

    def paintGL(self):
        self.paintAll()

    def myPaintGL(self):
        &#34;&#34;&#34;Paint the scene.
        &#34;&#34;&#34;
        if self.trace_calls:
            t = trace_method(self.tab)
        self.start_timing()
        if self.textureID is None:
            print(&#34;GLImageViewer paintGL not textureID&#34;)
            return
        gl.glClear(gl.GL_COLOR_BUFFER_BIT)
        gl.glTexEnvi(gl.GL_TEXTURE_ENV, gl.GL_TEXTURE_ENV_MODE, gl.GL_DECAL)
        gl.glBindTexture(gl.GL_TEXTURE_2D, self.textureID)
        # gl.glGenerateMipmap (gl.GL_TEXTURE_2D)
        gl.glEnable(gl.GL_TEXTURE_2D)
        gl.glBegin(gl.GL_QUADS)

        x0, x1, y0, y1 = self.image_centered_position()
        x0 = int(x0)
        x1 = int(x1)
        y0 = int(y0)
        y1 = int(y1)
        # print(&#34;{} {} {} {}&#34;.format(x0,x1,y0,y1))

        gl.glTexCoord2i(0, 0)
        gl.glVertex2i(x0, y1)

        gl.glTexCoord2i(0, 1)
        gl.glVertex2i(x0, y0)

        gl.glTexCoord2i(1, 1)
        gl.glVertex2i(x1, y0)

        gl.glTexCoord2i(1, 0)
        gl.glVertex2i(x1, y1)

        gl.glEnd()

        gl.glDisable(gl.GL_TEXTURE_2D)
        gl.glTexEnvi(gl.GL_TEXTURE_ENV, gl.GL_TEXTURE_ENV_MODE, gl.GL_MODULATE)

        self.print_timing(add_total=True)
        self.opengl_error()

    def resizeGL(self, width, height):
        &#34;&#34;&#34;Called upon window resizing: reinitialize the viewport.
        &#34;&#34;&#34;
        # print(&#34;ResizeGL&#34;)
        if self.trace_calls:
            t = trace_method(self.tab)
        # size give for opengl are in pixels, qt uses device independent size otherwise
        print(f&#34;self.devicePixelRatio() {self.devicePixelRatio()}&#34;)
        self._width = width*self.devicePixelRatio()
        self._height = height*self.devicePixelRatio()
        # print(&#34;width height ratios {} {}&#34;.format(self._width/self.width(), self._height/self.height()))
        self.viewer_update()

    def event(self, evt):
        if self.event_recorder is not None:
            self.event_recorder.store_event(self, evt)
        return super().event(evt)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase">GLImageViewerBase</a></li>
<li>PySide6.QtOpenGLWidgets.QOpenGLWidget</li>
<li>PySide6.QtWidgets.QWidget</li>
<li>PySide6.QtCore.QObject</li>
<li>PySide6.QtGui.QPaintDevice</li>
<li>Shiboken.Object</li>
<li><a title="qimview.image_viewers.image_viewer.ImageViewer" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer">ImageViewer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qimview.image_viewers.GLImageViewer.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qimview.image_viewers.GLImageViewer.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>self, evt)</span>
</code></dt>
<dd>
<div class="desc"><p>event(self, e: PySide6.QtCore.QEvent) -&gt; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(self, evt):
    if self.event_recorder is not None:
        self.event_recorder.store_event(self, evt)
    return super().event(evt)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewer.initializeGL"><code class="name flex">
<span>def <span class="ident">initializeGL</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize OpenGL, VBOs, upload data on the GPU, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initializeGL(self):
    &#34;&#34;&#34;Initialize OpenGL, VBOs, upload data on the GPU, etc.
    &#34;&#34;&#34;
    # self.setTexture()
    pass</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewer.myPaintGL"><code class="name flex">
<span>def <span class="ident">myPaintGL</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Paint the scene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def myPaintGL(self):
    &#34;&#34;&#34;Paint the scene.
    &#34;&#34;&#34;
    if self.trace_calls:
        t = trace_method(self.tab)
    self.start_timing()
    if self.textureID is None:
        print(&#34;GLImageViewer paintGL not textureID&#34;)
        return
    gl.glClear(gl.GL_COLOR_BUFFER_BIT)
    gl.glTexEnvi(gl.GL_TEXTURE_ENV, gl.GL_TEXTURE_ENV_MODE, gl.GL_DECAL)
    gl.glBindTexture(gl.GL_TEXTURE_2D, self.textureID)
    # gl.glGenerateMipmap (gl.GL_TEXTURE_2D)
    gl.glEnable(gl.GL_TEXTURE_2D)
    gl.glBegin(gl.GL_QUADS)

    x0, x1, y0, y1 = self.image_centered_position()
    x0 = int(x0)
    x1 = int(x1)
    y0 = int(y0)
    y1 = int(y1)
    # print(&#34;{} {} {} {}&#34;.format(x0,x1,y0,y1))

    gl.glTexCoord2i(0, 0)
    gl.glVertex2i(x0, y1)

    gl.glTexCoord2i(0, 1)
    gl.glVertex2i(x0, y0)

    gl.glTexCoord2i(1, 1)
    gl.glVertex2i(x1, y0)

    gl.glTexCoord2i(1, 0)
    gl.glVertex2i(x1, y1)

    gl.glEnd()

    gl.glDisable(gl.GL_TEXTURE_2D)
    gl.glTexEnvi(gl.GL_TEXTURE_ENV, gl.GL_TEXTURE_ENV_MODE, gl.GL_MODULATE)

    self.print_timing(add_total=True)
    self.opengl_error()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewer.paintGL"><code class="name flex">
<span>def <span class="ident">paintGL</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>paintGL(self) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintGL(self):
    self.paintAll()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewer.viewer_update"><code class="name flex">
<span>def <span class="ident">viewer_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewer_update(self):
    self.update()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase">GLImageViewerBase</a></b></code>:
<ul class="hlist">
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.display_histogram" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.display_histogram">display_histogram</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.find_in_layout" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.find_in_layout">find_in_layout</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.keyPressEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.keyPressEvent">keyPressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseDoubleClickEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseDoubleClickEvent">mouseDoubleClickEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseMoveEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mousePressEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseReleaseEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeGL" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeGL">resizeGL</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.setTexture" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.setTexture">setTexture</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.set_cursor_image_position" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.set_cursor_image_position">set_cursor_image_position</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.synchronize" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.synchronize">synchronize</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.wheelEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.wheelEvent">wheelEvent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders"><code class="flex name class">
<span>class <span class="ident">GLImageViewerShaders</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QOpenGLWidget(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p><strong>init</strong>(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p>Initialize self.
See help(type(self)) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GLImageViewerShaders(GLImageViewerBase):
    # vertex shader program
    vertexShader = &#34;&#34;&#34;
        #version 330 core

        attribute vec3 vert;
        attribute vec2 uV;
        uniform mat4 mvMatrix;
        uniform mat4 pMatrix;
        out vec2 UV;

        void main() {
          gl_Position = pMatrix * mvMatrix * vec4(vert, 1.0);
          UV = uV;
        }
        &#34;&#34;&#34;
    # fragment shader program
    fragmentShader_RGB = &#34;&#34;&#34;
        #version 330 core
    
        in vec2 UV;
        uniform sampler2D backgroundTexture;
        uniform int channels; // channel representation
        uniform float white_level;
        uniform float black_level;
        uniform float g_r_coeff;
        uniform float g_b_coeff;
        uniform float max_value; // maximal value based on image precision
        uniform float max_type;  // maximal value based on image type (uint8, etc...)
        uniform float gamma;
        out vec3 colour;
    
        void main() {
          colour = texture(backgroundTexture, UV).rgb;

          // black level
          colour.rgb = colour.rgb/max_value*max_type;
          colour.rgb = max((colour.rgb-vec3(black_level).rgb),0);

          // white balance
          colour.r = colour.r*g_r_coeff;
          colour.b = colour.b*g_b_coeff;

          // rescale to white level as saturation level
          colour.rgb = colour.rgb/(white_level-black_level);
          
          // apply gamma
          colour.rgb = pow(colour.rgb, vec3(1.0/gamma).rgb);

        }
    &#34;&#34;&#34;

    fragmentShader_RAW = &#34;&#34;&#34;
        #version 330 core
        
        in vec2 UV;
        uniform sampler2D backgroundTexture;
        uniform int channels; // channel representation
        uniform float white_level;
        uniform float black_level;
        uniform float g_r_coeff;
        uniform float g_b_coeff;
        uniform float max_value; // maximal value based on image precision
        uniform float max_type;  // maximal value based on image type (uint8, etc...)
        uniform float gamma;
        out vec3 colour;

        void main() {

           const int CH_RGGB = 4; // phase 0, bayer 2
           const int CH_GRBG = 5; // phase 1, bayer 3 (Boilers)
           const int CH_GBRG = 6; // phase 2, bayer 0
           const int CH_BGGR = 7; // phase 3, bayer 1 (Coconuts)

          vec4 bayer = texture(backgroundTexture, UV);
          // transform bayer data to RGB
          int r,gr,gb,b;
          switch (channels) {
            case 4:   r = 0; gr = 1; gb = 2; b = 3;  break; // CH_RGGB = 4 phase 0, bayer 2
            case 5:   r = 1; gr = 0; gb = 3; b = 2;  break; // CH_GRBG = 5 phase 1, bayer 3 (Boilers)
            case 6:   r = 2; gr = 3; gb = 0; b = 1;  break; // CH_GBRG = 6 phase 2, bayer 0
            case 7:   r = 3; gr = 2; gb = 1; b = 0;  break; // CH_BGGR = 7 phase 3, bayer 1 (Coconuts)
            default:        r = 0; gr = 1; gb = 2; b = 3;  break; // this should not happen
          }

          // first retreive black point to get the coefficients right ...
          // 5% of dynamics?
          
          // bayer 2 rgb
          colour.r   = bayer[r];
          colour.g = (bayer[gr]+bayer[gb])/2.0;
          colour.b = bayer[b];

          // black level
          colour.rgb = colour.rgb/max_value*max_type;
          colour.rgb = max((colour.rgb-vec3(black_level).rgb),0);
          
          // white balance
          colour.r = colour.r*g_r_coeff;
          colour.b = colour.b*g_b_coeff;

          // rescale to white level as saturation level
          colour.rgb = colour.rgb/(white_level-black_level);
          
          // apply gamma
          colour.rgb = pow(colour.rgb, vec3(1.0/gamma).rgb);
        }
    &#34;&#34;&#34;

    def __init__(self, parent=None):
        super().__init__(parent)

        self.setAutoFillBackground(False)
        self.textureID = None
        self.tex_width, self.tex_height = 0, 0
        self.opengl_debug = False
        self.synchronize_viewer = None
        self.pMatrix  = np.identity(4, dtype=np.float32)
        self.mvMatrix = np.identity(4, dtype=np.float32)
        self.program_RGB = None
        self.program_RAW = None
        self.program = None
        self.vertexBuffer = None

    def set_shaders(self):
        if self.program_RGB is None:
            vs = shaders.compileShader(self.vertexShader, gl.GL_VERTEX_SHADER)
            fs = shaders.compileShader(self.fragmentShader_RGB, gl.GL_FRAGMENT_SHADER)
            try:
                self.program_RGB = shaders.compileProgram(vs, fs, validate=False)
                print(&#34;\n***** self.program_RGB = {} *****\n&#34;.format(self.program_RGB))
            except Exception as e:
                print(&#39;failed RGB shaders.compileProgram() {}&#39;.format(e))
            shaders.glDeleteShader(vs)
            shaders.glDeleteShader(fs)

        if self.program_RAW is None:
            vs = shaders.compileShader(self.vertexShader, gl.GL_VERTEX_SHADER)
            fs = shaders.compileShader(self.fragmentShader_RAW, gl.GL_FRAGMENT_SHADER)
            try:
                self.program_RAW = shaders.compileProgram(vs, fs, validate=False)
                print(&#34;\n***** self.program_RAW = {} *****\n&#34;.format(self.program_RAW))
            except Exception as e:
                print(&#39;failed RAW shaders.compileProgram() {}&#39;.format(e))
            shaders.glDeleteShader(vs)
            shaders.glDeleteShader(fs)

    def setVerticesBufferData(self):
        try:
            x0, x1, y0, y1 = self.image_centered_position()
            # print(&#34; x0, x1, y0, y1 {} {} {} {}&#34;.format(x0, x1, y0, y1))
        except Exception as e:
            print(&#34; Failed image_centered_position() {}&#34;.format(e))
            x0, x1, y0, y1 = 0, 100, 0, 100
            # set background vertices
        backgroundVertices = [
            x0, y1, 0.0,
            x0, y0, 0.0,
            x1, y1, 0.0,
            x1, y1, 0.0,
            x0, y0, 0.0,
            x1, y0, 0.0]
        vertexData = np.array(backgroundVertices, np.float32)

        if self.vertexBuffer is not None:
            self.vertexBuffer.destroy()
        self.vertexBuffer = QOpenGLBuffer()
        self.vertexBuffer.create()
        self.vertexBuffer.bind()
        self.vertexBuffer.allocate(vertexData, 4 * len(vertexData))

    def setBufferData(self):
        # set background UV
        backgroundUV = [
            0.0, 0.0,
            0.0, 1.0,
            1.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            1.0, 1.0]
        uvData = np.array(backgroundUV, np.float32)

        self.uvBuffer = QOpenGLBuffer()
        self.uvBuffer.create()
        self.uvBuffer.bind()
        self.uvBuffer.allocate(uvData, 4 * len(uvData))

    def setTexture(self):
        texture_ok = super(GLImageViewerShaders, self).setTexture()
        self.setVerticesBufferData()
        return texture_ok

    def resizeGL(self, width, height):
        &#34;&#34;&#34;Called upon window resizing: reinitialize the viewport.
        &#34;&#34;&#34;
        # print(f&#34;resizeGL {width}x{height}&#34;)
        if self.trace_calls:
            t = trace_method(self.tab)
        self._width = width*self.devicePixelRatio()
        self._height = height*self.devicePixelRatio()
        self.setVerticesBufferData()
        self.update()

    def initializeGL(self):
        &#34;&#34;&#34;
        Initialize OpenGL, VBOs, upload data on the GPU, etc.
        &#34;&#34;&#34;
        self.start_timing()

        time1 = get_time()
        self.set_shaders()
        self.add_time(&#39;set_shaders&#39;, time1)

        self.setVerticesBufferData()
        self.setBufferData()
        self.print_timing()

    def viewer_update(self):
        self.update()

    def paintGL(self):
        self.paintAll()

    def myPaintGL(self):
        &#34;&#34;&#34;Paint the scene.
        &#34;&#34;&#34;
        if self.textureID is None or not self.isValid():
            print(&#34;paintGL() not ready&#34;)
            return
        self.opengl_error()
        self.start_timing()

        gl.glClear(gl.GL_COLOR_BUFFER_BIT)

        if self._image.data.shape[2] == 4:
            self.program = self.program_RAW
        else:
            # TODO: check for other types: scalar ...
            self.program = self.program_RGB

        # Obtain uniforms and attributes
        self.aVert              = shaders.glGetAttribLocation(self.program, &#34;vert&#34;)
        self.aUV                = shaders.glGetAttribLocation(self.program, &#34;uV&#34;)
        self.uPMatrix           = shaders.glGetUniformLocation(self.program, &#39;pMatrix&#39;)
        self.uMVMatrix          = shaders.glGetUniformLocation(self.program, &#34;mvMatrix&#34;)
        self.uBackgroundTexture = shaders.glGetUniformLocation(self.program, &#34;backgroundTexture&#34;)
        self.channels_location    = shaders.glGetUniformLocation(self.program, &#34;channels&#34;)
        self.black_level_location = shaders.glGetUniformLocation(self.program, &#34;black_level&#34;)
        self.white_level_location = shaders.glGetUniformLocation(self.program, &#34;white_level&#34;)
        self.g_r_coeff_location   = shaders.glGetUniformLocation(self.program, &#34;g_r_coeff&#34;)
        self.g_b_coeff_location   = shaders.glGetUniformLocation(self.program, &#34;g_b_coeff&#34;)
        self.max_value_location   = shaders.glGetUniformLocation(self.program, &#34;max_value&#34;)
        self.max_type_location    = shaders.glGetUniformLocation(self.program, &#34;max_type&#34;)
        self.gamma_location       = shaders.glGetUniformLocation(self.program, &#34;gamma&#34;)

        # use shader program
        self.print_log(&#34;self.program = {}&#34;.format(self.program))
        shaders.glUseProgram(self.program)

        # set uniforms
        gl.glUniformMatrix4fv(self.uPMatrix, 1, gl.GL_FALSE, self.pMatrix)
        gl.glUniformMatrix4fv(self.uMVMatrix, 1, gl.GL_FALSE, self.mvMatrix)
        gl.glUniform1i(self.uBackgroundTexture, 0)

        gl.glUniform1i( self.channels_location, self._image.channels)

        # set color transformation parameters
        self.print_log(&#34;levels {} {}&#34;.format(self.filter_params.black_level.value,
                                             self.filter_params.white_level.value))
        gl.glUniform1f( self.black_level_location, self.filter_params.black_level.float)
        gl.glUniform1f( self.white_level_location, self.filter_params.white_level.float)

        # white balance coefficients
        gl.glUniform1f(self.g_r_coeff_location, self.filter_params.g_r.float)
        gl.glUniform1f(self.g_b_coeff_location, self.filter_params.g_b.float)

        # Should work for unsigned types for the moment
        gl.glUniform1f( self.max_value_location, (1 &lt;&lt; self._image.precision)-1)
        gl.glUniform1f( self.max_type_location,  np.iinfo(self._image.data.dtype).max)

        gl.glUniform1f( self.gamma_location,       self.filter_params.gamma.float)

        # enable attribute arrays
        gl.glEnableVertexAttribArray(self.aVert)
        gl.glEnableVertexAttribArray(self.aUV)

        # set vertex and UV buffers
        # vert_buffers = VertexBuffers()
        # vert_buffers.vert_pos_buffer = vert_pos_buffer
        # vert_buffers.normal_buffer = normal_buffer
        # vert_buffers.tex_coord_buffer = tex_coord_buffer
        # vert_buffers.amount_of_vertices = int(len(index_array) / 3)

        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.vertexBuffer.bufferId())
        gl.glVertexAttribPointer(self.aVert, 3, gl.GL_FLOAT, gl.GL_FALSE, 0, None)
        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.uvBuffer.bufferId())
        gl.glVertexAttribPointer(self.aUV, 2, gl.GL_FLOAT, gl.GL_FALSE, 0, None)

        # bind background texture
        # gl.glActiveTexture(gl.GL_TEXTURE0)
        gl.glBindTexture(gl.GL_TEXTURE_2D, self.textureID)
        gl.glEnable(gl.GL_TEXTURE_2D)

        # draw
        gl.glDrawArrays(gl.GL_TRIANGLES, 0, 6)

        # disable attribute arrays
        gl.glDisableVertexAttribArray(self.aVert)
        gl.glDisableVertexAttribArray(self.aUV)
        gl.glDisable(gl.GL_TEXTURE_2D)

        shaders.glUseProgram(0)

        self.print_timing(force=True)

    def updateTransforms(self) -&gt; float:
        if self.trace_calls:
            t = trace_method(self.tab)
        if self.display_timing:
            start_time = get_time()
        self.makeCurrent()
        w = self._width
        h = self._height
        dx, dy = self.new_translation()
        # scale = max(self.mouse_zx, self.mouse_zy)
        scale = self.new_scale(self.mouse_zy, self.tex_height)
        # update the window size
        gl.glMatrixMode(gl.GL_PROJECTION)
        gl.glLoadIdentity()
        translation_unit = min(w, h)/2
        gl.glScale(scale, scale, scale)
        gl.glTranslate(dx/translation_unit, dy/translation_unit, 0)
        # the window corner OpenGL coordinates are (-+1, -+1)
        gl.glOrtho(0, w, 0, h, -1, 1)
        self.pMatrix = np.array(gl.glGetFloatv(gl.GL_PROJECTION_MATRIX), dtype=np.float32).flatten()

        gl.glMatrixMode(gl.GL_MODELVIEW)
        gl.glLoadIdentity()
        self.mvMatrix = np.array(gl.glGetFloatv(gl.GL_MODELVIEW_MATRIX), dtype=np.float32).flatten()
        if self.display_timing:
            self.print_log(&#39;updateTransforms time {:0.1f} ms&#39;.format((get_time()-start_time)*1000))
        return scale</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase">GLImageViewerBase</a></li>
<li>PySide6.QtOpenGLWidgets.QOpenGLWidget</li>
<li>PySide6.QtWidgets.QWidget</li>
<li>PySide6.QtCore.QObject</li>
<li>PySide6.QtGui.QPaintDevice</li>
<li>Shiboken.Object</li>
<li><a title="qimview.image_viewers.image_viewer.ImageViewer" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer">ImageViewer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qimview.image_viewers.GLImageViewerShaders.fragmentShader_RAW"><code class="name">var <span class="ident">fragmentShader_RAW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.fragmentShader_RGB"><code class="name">var <span class="ident">fragmentShader_RGB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.vertexShader"><code class="name">var <span class="ident">vertexShader</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qimview.image_viewers.GLImageViewerShaders.initializeGL"><code class="name flex">
<span>def <span class="ident">initializeGL</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize OpenGL, VBOs, upload data on the GPU, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initializeGL(self):
    &#34;&#34;&#34;
    Initialize OpenGL, VBOs, upload data on the GPU, etc.
    &#34;&#34;&#34;
    self.start_timing()

    time1 = get_time()
    self.set_shaders()
    self.add_time(&#39;set_shaders&#39;, time1)

    self.setVerticesBufferData()
    self.setBufferData()
    self.print_timing()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.myPaintGL"><code class="name flex">
<span>def <span class="ident">myPaintGL</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Paint the scene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def myPaintGL(self):
    &#34;&#34;&#34;Paint the scene.
    &#34;&#34;&#34;
    if self.textureID is None or not self.isValid():
        print(&#34;paintGL() not ready&#34;)
        return
    self.opengl_error()
    self.start_timing()

    gl.glClear(gl.GL_COLOR_BUFFER_BIT)

    if self._image.data.shape[2] == 4:
        self.program = self.program_RAW
    else:
        # TODO: check for other types: scalar ...
        self.program = self.program_RGB

    # Obtain uniforms and attributes
    self.aVert              = shaders.glGetAttribLocation(self.program, &#34;vert&#34;)
    self.aUV                = shaders.glGetAttribLocation(self.program, &#34;uV&#34;)
    self.uPMatrix           = shaders.glGetUniformLocation(self.program, &#39;pMatrix&#39;)
    self.uMVMatrix          = shaders.glGetUniformLocation(self.program, &#34;mvMatrix&#34;)
    self.uBackgroundTexture = shaders.glGetUniformLocation(self.program, &#34;backgroundTexture&#34;)
    self.channels_location    = shaders.glGetUniformLocation(self.program, &#34;channels&#34;)
    self.black_level_location = shaders.glGetUniformLocation(self.program, &#34;black_level&#34;)
    self.white_level_location = shaders.glGetUniformLocation(self.program, &#34;white_level&#34;)
    self.g_r_coeff_location   = shaders.glGetUniformLocation(self.program, &#34;g_r_coeff&#34;)
    self.g_b_coeff_location   = shaders.glGetUniformLocation(self.program, &#34;g_b_coeff&#34;)
    self.max_value_location   = shaders.glGetUniformLocation(self.program, &#34;max_value&#34;)
    self.max_type_location    = shaders.glGetUniformLocation(self.program, &#34;max_type&#34;)
    self.gamma_location       = shaders.glGetUniformLocation(self.program, &#34;gamma&#34;)

    # use shader program
    self.print_log(&#34;self.program = {}&#34;.format(self.program))
    shaders.glUseProgram(self.program)

    # set uniforms
    gl.glUniformMatrix4fv(self.uPMatrix, 1, gl.GL_FALSE, self.pMatrix)
    gl.glUniformMatrix4fv(self.uMVMatrix, 1, gl.GL_FALSE, self.mvMatrix)
    gl.glUniform1i(self.uBackgroundTexture, 0)

    gl.glUniform1i( self.channels_location, self._image.channels)

    # set color transformation parameters
    self.print_log(&#34;levels {} {}&#34;.format(self.filter_params.black_level.value,
                                         self.filter_params.white_level.value))
    gl.glUniform1f( self.black_level_location, self.filter_params.black_level.float)
    gl.glUniform1f( self.white_level_location, self.filter_params.white_level.float)

    # white balance coefficients
    gl.glUniform1f(self.g_r_coeff_location, self.filter_params.g_r.float)
    gl.glUniform1f(self.g_b_coeff_location, self.filter_params.g_b.float)

    # Should work for unsigned types for the moment
    gl.glUniform1f( self.max_value_location, (1 &lt;&lt; self._image.precision)-1)
    gl.glUniform1f( self.max_type_location,  np.iinfo(self._image.data.dtype).max)

    gl.glUniform1f( self.gamma_location,       self.filter_params.gamma.float)

    # enable attribute arrays
    gl.glEnableVertexAttribArray(self.aVert)
    gl.glEnableVertexAttribArray(self.aUV)

    # set vertex and UV buffers
    # vert_buffers = VertexBuffers()
    # vert_buffers.vert_pos_buffer = vert_pos_buffer
    # vert_buffers.normal_buffer = normal_buffer
    # vert_buffers.tex_coord_buffer = tex_coord_buffer
    # vert_buffers.amount_of_vertices = int(len(index_array) / 3)

    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.vertexBuffer.bufferId())
    gl.glVertexAttribPointer(self.aVert, 3, gl.GL_FLOAT, gl.GL_FALSE, 0, None)
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.uvBuffer.bufferId())
    gl.glVertexAttribPointer(self.aUV, 2, gl.GL_FLOAT, gl.GL_FALSE, 0, None)

    # bind background texture
    # gl.glActiveTexture(gl.GL_TEXTURE0)
    gl.glBindTexture(gl.GL_TEXTURE_2D, self.textureID)
    gl.glEnable(gl.GL_TEXTURE_2D)

    # draw
    gl.glDrawArrays(gl.GL_TRIANGLES, 0, 6)

    # disable attribute arrays
    gl.glDisableVertexAttribArray(self.aVert)
    gl.glDisableVertexAttribArray(self.aUV)
    gl.glDisable(gl.GL_TEXTURE_2D)

    shaders.glUseProgram(0)

    self.print_timing(force=True)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.paintGL"><code class="name flex">
<span>def <span class="ident">paintGL</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>paintGL(self) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintGL(self):
    self.paintAll()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.setBufferData"><code class="name flex">
<span>def <span class="ident">setBufferData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBufferData(self):
    # set background UV
    backgroundUV = [
        0.0, 0.0,
        0.0, 1.0,
        1.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,
        1.0, 1.0]
    uvData = np.array(backgroundUV, np.float32)

    self.uvBuffer = QOpenGLBuffer()
    self.uvBuffer.create()
    self.uvBuffer.bind()
    self.uvBuffer.allocate(uvData, 4 * len(uvData))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.setVerticesBufferData"><code class="name flex">
<span>def <span class="ident">setVerticesBufferData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setVerticesBufferData(self):
    try:
        x0, x1, y0, y1 = self.image_centered_position()
        # print(&#34; x0, x1, y0, y1 {} {} {} {}&#34;.format(x0, x1, y0, y1))
    except Exception as e:
        print(&#34; Failed image_centered_position() {}&#34;.format(e))
        x0, x1, y0, y1 = 0, 100, 0, 100
        # set background vertices
    backgroundVertices = [
        x0, y1, 0.0,
        x0, y0, 0.0,
        x1, y1, 0.0,
        x1, y1, 0.0,
        x0, y0, 0.0,
        x1, y0, 0.0]
    vertexData = np.array(backgroundVertices, np.float32)

    if self.vertexBuffer is not None:
        self.vertexBuffer.destroy()
    self.vertexBuffer = QOpenGLBuffer()
    self.vertexBuffer.create()
    self.vertexBuffer.bind()
    self.vertexBuffer.allocate(vertexData, 4 * len(vertexData))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.set_shaders"><code class="name flex">
<span>def <span class="ident">set_shaders</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_shaders(self):
    if self.program_RGB is None:
        vs = shaders.compileShader(self.vertexShader, gl.GL_VERTEX_SHADER)
        fs = shaders.compileShader(self.fragmentShader_RGB, gl.GL_FRAGMENT_SHADER)
        try:
            self.program_RGB = shaders.compileProgram(vs, fs, validate=False)
            print(&#34;\n***** self.program_RGB = {} *****\n&#34;.format(self.program_RGB))
        except Exception as e:
            print(&#39;failed RGB shaders.compileProgram() {}&#39;.format(e))
        shaders.glDeleteShader(vs)
        shaders.glDeleteShader(fs)

    if self.program_RAW is None:
        vs = shaders.compileShader(self.vertexShader, gl.GL_VERTEX_SHADER)
        fs = shaders.compileShader(self.fragmentShader_RAW, gl.GL_FRAGMENT_SHADER)
        try:
            self.program_RAW = shaders.compileProgram(vs, fs, validate=False)
            print(&#34;\n***** self.program_RAW = {} *****\n&#34;.format(self.program_RAW))
        except Exception as e:
            print(&#39;failed RAW shaders.compileProgram() {}&#39;.format(e))
        shaders.glDeleteShader(vs)
        shaders.glDeleteShader(fs)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.updateTransforms"><code class="name flex">
<span>def <span class="ident">updateTransforms</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateTransforms(self) -&gt; float:
    if self.trace_calls:
        t = trace_method(self.tab)
    if self.display_timing:
        start_time = get_time()
    self.makeCurrent()
    w = self._width
    h = self._height
    dx, dy = self.new_translation()
    # scale = max(self.mouse_zx, self.mouse_zy)
    scale = self.new_scale(self.mouse_zy, self.tex_height)
    # update the window size
    gl.glMatrixMode(gl.GL_PROJECTION)
    gl.glLoadIdentity()
    translation_unit = min(w, h)/2
    gl.glScale(scale, scale, scale)
    gl.glTranslate(dx/translation_unit, dy/translation_unit, 0)
    # the window corner OpenGL coordinates are (-+1, -+1)
    gl.glOrtho(0, w, 0, h, -1, 1)
    self.pMatrix = np.array(gl.glGetFloatv(gl.GL_PROJECTION_MATRIX), dtype=np.float32).flatten()

    gl.glMatrixMode(gl.GL_MODELVIEW)
    gl.glLoadIdentity()
    self.mvMatrix = np.array(gl.glGetFloatv(gl.GL_MODELVIEW_MATRIX), dtype=np.float32).flatten()
    if self.display_timing:
        self.print_log(&#39;updateTransforms time {:0.1f} ms&#39;.format((get_time()-start_time)*1000))
    return scale</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.GLImageViewerShaders.viewer_update"><code class="name flex">
<span>def <span class="ident">viewer_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewer_update(self):
    self.update()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase">GLImageViewerBase</a></b></code>:
<ul class="hlist">
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.display_histogram" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.display_histogram">display_histogram</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.find_in_layout" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.find_in_layout">find_in_layout</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.keyPressEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.keyPressEvent">keyPressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseDoubleClickEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseDoubleClickEvent">mouseDoubleClickEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseMoveEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mousePressEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseReleaseEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeGL" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.resizeGL">resizeGL</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.setTexture" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.setTexture">setTexture</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.set_cursor_image_position" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.set_cursor_image_position">set_cursor_image_position</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.synchronize" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.synchronize">synchronize</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.wheelEvent" href="gl_image_viewer_base.html#qimview.image_viewers.gl_image_viewer_base.GLImageViewerBase.wheelEvent">wheelEvent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qimview.image_viewers.ImageFilterParameters"><code class="flex name class">
<span>class <span class="ident">ImageFilterParameters</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageFilterParameters:
    def __init__(self):
        # white/black levels
        # default_black = int(4095*5/100)
        default_black = 0
        self.black_level = NumericParameter(default_black, default_black, [0, 4095]  , 4095)
        self.white_level = NumericParameter(4095, 4095,            [480, 4095], 4095)
        # gamma curve coefficient
        self.gamma       = NumericParameter(100, 100,            [50, 300], 100)
        # white balance coefficients
        self.g_b = NumericParameter(256, 256, [50, 512], 256)
        self.g_r = NumericParameter(256, 256, [50, 512], 256)
        # Saturation
        self.saturation = NumericParameter(50, 50, [0, 150], 50)
        # Image difference factor
        self.imdiff_factor = NumericParameter(30, 30, [1, 100], 10)

    def copy_from(self, p):
        for v in vars(self):
            if isinstance(self.__dict__[v], NumericParameter):
                self.__dict__[v].copy_from(p.__dict__[v])

    def is_equal(self, other):
        if not isinstance(other, ImageFilterParameters):
            return NotImplemented
        for v in vars(self):
            var1 = self.__dict__[v]
            if isinstance(var1, NumericParameter):
                var2 = other.__dict__[v]
                if var1.float != var2.float:
                    return False
        return True

    def __repr__(self):
        return f&#34;&lt;ImageFilterParameters {id(self)}&gt;&#34;

    def __str__(self):
        res = &#34;&#34;
        for v in vars(self):
            res += f&#34;{v}:{self.__dict__[v]}; &#34;
        return res</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="qimview.image_viewers.ImageFilterParameters.copy_from"><code class="name flex">
<span>def <span class="ident">copy_from</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_from(self, p):
    for v in vars(self):
        if isinstance(self.__dict__[v], NumericParameter):
            self.__dict__[v].copy_from(p.__dict__[v])</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParameters.is_equal"><code class="name flex">
<span>def <span class="ident">is_equal</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_equal(self, other):
    if not isinstance(other, ImageFilterParameters):
        return NotImplemented
    for v in vars(self):
        var1 = self.__dict__[v]
        if isinstance(var1, NumericParameter):
            var2 = other.__dict__[v]
            if var1.float != var2.float:
                return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui"><code class="flex name class">
<span>class <span class="ident">ImageFilterParametersGui</span></span>
<span>(</span><span>parameters, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>:param parameters: instance of ImageFilterParameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageFilterParametersGui:
    def __init__(self, parameters, name=&#34;&#34;):
        &#34;&#34;&#34;
        :param parameters: instance of ImageFilterParameters
        &#34;&#34;&#34;
        self.params    = parameters
        self.bl_gui    = None
        self.wl_gui    = None
        self.gamma_gui = None
        self.g_r_gui   = None
        self.g_b_gui   = None
        self.saturation_gui    = None
        self.imdiff_factor_gui = None
        self.event_recorder    = None
        self.name              = name

    def set_event_recorder(self, evtrec):
        self.event_recorder = evtrec

    def add_blackpoint(self, layout, callback):
        self.bl_gui = NumericParameterGui(&#34;Black&#34;, self.params.black_level, callback, layout, self.name)
        self.bl_gui.set_event_recorder(self.event_recorder)

    def add_whitepoint(self, layout, callback):
        self.wl_gui = NumericParameterGui(&#34;White&#34;, self.params.white_level, callback, layout, self.name)
        self.wl_gui.set_event_recorder(self.event_recorder)

    def add_gamma(self, layout, callback):
        self.gamma_gui = NumericParameterGui(&#34;Gamma&#34;, self.params.gamma, callback, layout, self.name)
        self.gamma_gui.set_event_recorder(self.event_recorder)

    def add_g_r(self, layout, callback):
        self.g_r_gui = NumericParameterGui(&#34;G/R&#34;, self.params.g_r, callback, layout, self.name)
        self.g_r_gui.set_event_recorder(self.event_recorder)

    def add_g_b(self, layout, callback):
        self.g_b_gui = NumericParameterGui(&#34;G/B&#34;, self.params.g_b, callback, layout, self.name)
        self.g_b_gui.set_event_recorder(self.event_recorder)

    def add_saturation(self, layout, callback):
        self.saturation_gui = NumericParameterGui(&#34;Saturation&#34;, self.params.saturation, callback, layout, self.name)
        self.saturation_gui.set_event_recorder(self.event_recorder)

    def add_imdiff_factor(self, layout, callback):
        self.imdiff_factor_gui = NumericParameterGui(&#34;Image diff factor&#34;, self.params.imdiff_factor, callback, layout, self.name)
        self.imdiff_factor_gui.set_event_recorder(self.event_recorder)

    def register_event_player(self, event_player):
        for v in vars(self):
            if &#39;gui&#39; in v and self.__dict__[v]:
                self.__dict__[v].register_event_player(event_player)

    def reset_all(self):
        for v in vars(self):
            if &#39;gui&#39; in v:
                self.__dict__[v].reset()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="qimview.image_viewers.ImageFilterParametersGui.add_blackpoint"><code class="name flex">
<span>def <span class="ident">add_blackpoint</span></span>(<span>self, layout, callback)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_blackpoint(self, layout, callback):
    self.bl_gui = NumericParameterGui(&#34;Black&#34;, self.params.black_level, callback, layout, self.name)
    self.bl_gui.set_event_recorder(self.event_recorder)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.add_g_b"><code class="name flex">
<span>def <span class="ident">add_g_b</span></span>(<span>self, layout, callback)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_g_b(self, layout, callback):
    self.g_b_gui = NumericParameterGui(&#34;G/B&#34;, self.params.g_b, callback, layout, self.name)
    self.g_b_gui.set_event_recorder(self.event_recorder)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.add_g_r"><code class="name flex">
<span>def <span class="ident">add_g_r</span></span>(<span>self, layout, callback)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_g_r(self, layout, callback):
    self.g_r_gui = NumericParameterGui(&#34;G/R&#34;, self.params.g_r, callback, layout, self.name)
    self.g_r_gui.set_event_recorder(self.event_recorder)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.add_gamma"><code class="name flex">
<span>def <span class="ident">add_gamma</span></span>(<span>self, layout, callback)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_gamma(self, layout, callback):
    self.gamma_gui = NumericParameterGui(&#34;Gamma&#34;, self.params.gamma, callback, layout, self.name)
    self.gamma_gui.set_event_recorder(self.event_recorder)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.add_imdiff_factor"><code class="name flex">
<span>def <span class="ident">add_imdiff_factor</span></span>(<span>self, layout, callback)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_imdiff_factor(self, layout, callback):
    self.imdiff_factor_gui = NumericParameterGui(&#34;Image diff factor&#34;, self.params.imdiff_factor, callback, layout, self.name)
    self.imdiff_factor_gui.set_event_recorder(self.event_recorder)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.add_saturation"><code class="name flex">
<span>def <span class="ident">add_saturation</span></span>(<span>self, layout, callback)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_saturation(self, layout, callback):
    self.saturation_gui = NumericParameterGui(&#34;Saturation&#34;, self.params.saturation, callback, layout, self.name)
    self.saturation_gui.set_event_recorder(self.event_recorder)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.add_whitepoint"><code class="name flex">
<span>def <span class="ident">add_whitepoint</span></span>(<span>self, layout, callback)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_whitepoint(self, layout, callback):
    self.wl_gui = NumericParameterGui(&#34;White&#34;, self.params.white_level, callback, layout, self.name)
    self.wl_gui.set_event_recorder(self.event_recorder)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.register_event_player"><code class="name flex">
<span>def <span class="ident">register_event_player</span></span>(<span>self, event_player)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_event_player(self, event_player):
    for v in vars(self):
        if &#39;gui&#39; in v and self.__dict__[v]:
            self.__dict__[v].register_event_player(event_player)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.reset_all"><code class="name flex">
<span>def <span class="ident">reset_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_all(self):
    for v in vars(self):
        if &#39;gui&#39; in v:
            self.__dict__[v].reset()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.ImageFilterParametersGui.set_event_recorder"><code class="name flex">
<span>def <span class="ident">set_event_recorder</span></span>(<span>self, evtrec)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_event_recorder(self, evtrec):
    self.event_recorder = evtrec</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qimview.image_viewers.MultiView"><code class="flex name class">
<span>class <span class="ident">MultiView</span></span>
<span>(</span><span>parent=None, viewer_mode: <a title="qimview.image_viewers.multi_view.ViewerType" href="multi_view.html#qimview.image_viewers.multi_view.ViewerType">ViewerType</a> = ViewerType.QT_VIEWER, nb_viewers: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>QWidget(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p>:param parent:
:param viewer_mode:
:param nb_viewers_used:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiView(QtWidgets.QWidget):

    def __init__(self, parent=None, viewer_mode: ViewerType =ViewerType.QT_VIEWER, nb_viewers: int =1) -&gt; None:
        &#34;&#34;&#34;
        :param parent:
        :param viewer_mode:
        :param nb_viewers_used:
        &#34;&#34;&#34;
        QtWidgets.QWidget.__init__(self, parent)

        self.use_opengl = viewer_mode in [ViewerType.OPENGL_SHADERS_VIEWER, ViewerType.OPENGL_VIEWER]

        self.nb_viewers_used : int = nb_viewers
        self.allocated_image_viewers = []  # keep allocated image viewers here
        self.image_viewers = []
        self.image_viewer_classes = {
            ViewerType.QT_VIEWER:             QTImageViewer,
            ViewerType.OPENGL_VIEWER:         GLImageViewer,
            ViewerType.OPENGL_SHADERS_VIEWER: GLImageViewerShaders
        }
        self.image_viewer_class = self.image_viewer_classes[viewer_mode]

        # Create viewer instances
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
            self.image_viewers.append(viewer)

        self.viewer_mode = viewer_mode
        self.bold_font = QtGui.QFont()

        self.verbosity_LIGHT = 1
        self.verbosity_TIMING = 1 &lt;&lt; 2
        self.verbosity_TIMING_DETAILED = 1 &lt;&lt; 3
        self.verbosity_TRACE = 1 &lt;&lt; 4
        self.verbosity_DEBUG = 1 &lt;&lt; 5
        self.verbosity = 0

        # self.set_verbosity(self.verbosity_LIGHT)
        # self.set_verbosity(self.verbosity_TIMING_DETAILED)
        # self.set_verbosity(self.verbosity_TRACE)

        self.current_image_filename = None
        self.save_image_clipboard = False

        self.filter_params = ImageFilterParameters()
        self.filter_params_gui = ImageFilterParametersGui(self.filter_params)

        self.raw_bayer = {&#39;Read&#39;: None, &#39;Bayer0&#39;: ImageFormat.CH_GBRG, &#39;Bayer1&#39;: ImageFormat.CH_BGGR, &#39;Bayer2&#39;: ImageFormat.CH_RGGB, &#39;Bayer3&#39;: ImageFormat.CH_GRBG}
        self.default_raw_bayer = &#39;Read&#39;
        self.current_raw_bayer = self.default_raw_bayer

        # Number of viewers currently displayed
        self.nb_viewers_used : int = 0

        # save images of last visited row
        self.cache = ImageCache()
        self.image_dict = { }
        self.read_size = &#39;full&#39;
        self.image1 = dict()
        self.image2 = dict()
        self.button_layout = None
        self.message_cb = None
        self.replacing_widget = self.before_max_parent = None

        if &#39;ClickFocus&#39; in QtCore.Qt.FocusPolicy.__dict__:
            self.setFocusPolicy(QtCore.Qt.FocusPolicy.ClickFocus)
        else:
            self.setFocusPolicy(QtCore.Qt.ClickFocus)

        self.key_up_callback = None
        self.key_down_callback = None
        self.output_image_label = dict()

        self.output_label_current_image   : str = &#39;&#39;
        self.output_label_reference_image : str = &#39;&#39;
        self.add_context_menu()
        
        # Parameter to set the number of columns in the viewer grid layout
        # if 0: computed automatically
        self.max_columns : int = 0 

    def set_key_up_callback(self, c):
        self.key_up_callback = c

    def set_key_down_callback(self, c):
        self.key_down_callback = c

    def add_context_menu(self):
        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self._context_menu = QtWidgets.QMenu()
        self.viewer_modes = {}
        for v in ViewerType:
            self.viewer_modes[v.name] = v
        self._default_viewer_mode = ViewerType.QT_VIEWER.name
        self.viewer_mode_selection = MenuSelection(&#34;Viewer mode&#34;, 
            self._context_menu, self.viewer_modes, self._default_viewer_mode, self.update_viewer_mode)
        self._context_menu.addSeparator()
        action = self._context_menu.addAction(&#34;Reset viewers&#34;)
        action.triggered.connect(self.reset_viewers)

    def reset_viewers(self):
        for v in self.image_viewers:
            v.hide()
            self.viewer_grid_layout.removeWidget(v)
        self.allocated_image_viewers.clear()
        self.image_viewers.clear()
        # Create viewer instances
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
            self.image_viewers.append(viewer)
        self.set_number_of_viewers(self.nb_viewers_used)
        self.viewer_grid_layout.update()
        self.update_image()

    def update_viewer_mode(self):
        viewer_mode = self.viewer_mode_selection.get_selection_value()
        self.image_viewer_class = self.image_viewer_classes[viewer_mode]

    def show_context_menu(self, pos):
        # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
        self._context_menu.show()
        self._context_menu.popup( self.mapToGlobal(pos) )

    def set_cache_memory_bar(self, progress_bar):
        self.cache.set_memory_bar(progress_bar)

    def set_verbosity(self, flag, enable=True):
        &#34;&#34;&#34;
        :param v: verbosity flags
        :param b: boolean to enable or disable flag
        :return:
        &#34;&#34;&#34;
        if enable:
            self.verbosity = self.verbosity | flag
        else:
            self.verbosity = self.verbosity &amp; ~flag

    def check_verbosity(self, flag):
        return self.verbosity &amp; flag

    def print_log(self, mess):
        if self.verbosity &amp; self.verbosity_LIGHT:
            print(mess)

    def show_timing(self):
        return self.check_verbosity(self.verbosity_TIMING) or self.check_verbosity(self.verbosity_TIMING_DETAILED)

    def show_timing_detailed(self):
        return self.check_verbosity(self.verbosity_TIMING_DETAILED)

    def show_trace(self):
        return self.check_verbosity(self.verbosity_TRACE)

    def make_mouse_press(self, image_name):
        def mouse_press(obj, event):
            print(&#39;mouse_press&#39;)
            obj.update_image(image_name)

        return types.MethodType(mouse_press, self)

    def mouse_release(self, event):
        self.update_image(self.output_label_reference_image)

    def make_mouse_double_click(self, image_name):
        def mouse_double_click(obj, event):
            &#39;&#39;&#39;
            Sets the double clicked label as the reference image
            :param obj:
            :param event:
            &#39;&#39;&#39;
            print(&#39;mouse_double_click {}&#39;.format(image_name))
            obj.output_label_reference_image = image_name
            obj.output_label_current_image = obj.output_label_reference_image
            obj.update_image()

        return types.MethodType(mouse_double_click, self)

    def set_read_size(self, read_size):
        self.read_size = read_size
        # reset cache
        self.cache.reset()

    def update_image_intensity_event(self):
        self.update_image_parameters()

    def reset_intensities(self):
        self.filter_params_gui.reset_all()

    def update_image_parameters(self):
        &#39;&#39;&#39;
        Uses the variable self.output_label_current_image
        :return:
        &#39;&#39;&#39;
        self.print_log(&#39;update_image_parameters&#39;)
        update_start = get_time()

        for n in range(self.nb_viewers_used):
            self.image_viewers[n].filter_params.copy_from(self.filter_params)
            self.image_viewers[n].update()

        if self.show_timing():
            time_spent = get_time() - update_start
            self.print_log(&#34; Update image took {0:0.3f} sec.&#34;.format(time_spent))

    def set_images(self, images, set_viewers=False):
        self.print_log(f&#34;MultiView.set_images() {images}&#34;)
        if images.keys() == self.image_dict.keys():
            self.image_dict = images
            self.update_reference()
        else:
            self.image_dict = images
            self.update_image_buttons()

    def set_viewer_images(self):
        &#34;&#34;&#34;
        Set viewer images based on self.image_dict.keys()
        :return:
        &#34;&#34;&#34;
        # if set_viewers, we force the viewer layout and images based on the list
        # be sure to have enough image viewers allocated
        while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)
        self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]
        image_names = list(self.image_dict.keys())
        for n in range(self.nb_viewers_used):
            if n &lt; len(image_names):
                self.image_viewers[n].image_name = image_names[n]
            else:
                self.image_viewers[n].image_name = image_names[len(image_names)-1]

    def update_reference(self) -&gt; None:
        reference_image = self.get_output_image(self.output_label_reference_image)
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewers[n]
            # set reference image
            viewer.set_image_ref(reference_image)

    def set_reference_label(self, ref: str, update_viewers=False) -&gt; None:
        try:
            if ref is not None:
                if ref!=self.output_label_reference_image:
                    self.output_label_reference_image = ref
                    if update_viewers:
                        self.update_reference()
        except Exception as e:
            print(f&#39; Failed to set reference label {e}&#39;)

    def update_image_buttons(self):
        # choose image to display
        self.clear_buttons()
        self.image_list = list(self.image_dict.keys())
        self.print_log(&#34;MultiView.update_image_buttons() {}&#34;.format(self.image_list))
        self.label = dict()
        for image_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if image_name != &#39;none&#39;:
                self.label[image_name] = MVLabel(image_name, self)
                self.label[image_name].setFrameShape(QtWidgets.QFrame.Panel)
                self.label[image_name].setFrameShadow(QtWidgets.QFrame.Sunken)
                # self.label[image_name].setLineWidth(3)
                self.label[image_name].setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
                # self.label[image_name].setFixedHeight(40)
                self.label[image_name].mousePressEvent = self.make_mouse_press(image_name)
                self.label[image_name].mouseReleaseEvent = self.mouse_release
                self.label[image_name].mouseDoubleClickEvent = self.make_mouse_double_click(image_name)
        self.create_buttons()

        # the crop area can be changed using the mouse wheel
        self.output_label_crop = (0., 0., 1., 1.)

        if len(self.image_list)&gt;0:
            self.output_label_current_image = self.image_list[0]
            self.set_reference_label(self.image_list[0], update_viewers=True)
        else:
            self.output_label_current_image = &#39;&#39;
            self.output_label_reference_image = &#39;&#39;

    def clear_buttons(self):
        if self.button_layout is not None:
            # start clearing the layout
            # for i in range(self.button_layout.count()): self.button_layout.itemAt(i).widget().close()
            self.print_log(f&#34;MultiView.clear_buttons() {self.image_list}&#34;)
            for image_name in reversed(self.image_list):
                if image_name in self.label:
                    self.button_layout.removeWidget(self.label[image_name])
                    self.label[image_name].close()

    def create_buttons(self):
        if self.button_layout is not None:
            max_grid_columns = 10
            idx = 0
            for image_name in self.image_list:
                # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
                if image_name != &#39;none&#39;:
                    self.button_layout.addWidget(self.label[image_name], idx // max_grid_columns, idx % max_grid_columns)
                    idx += 1

    def layout_buttons(self, vertical_layout):
        self.button_widget = QtWidgets.QWidget(self)
        self.button_layout = QtWidgets.QGridLayout()
        self.button_layout.setHorizontalSpacing(0)
        self.button_layout.setVerticalSpacing(0)
        # button_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        self.create_buttons()
        vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        # vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetNoConstraint)
        self.button_widget.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        self.button_widget.setLayout(self.button_layout)
        vertical_layout.addWidget(self.button_widget, 0, QtCore.Qt.AlignTop)

    def layout_parameters(self, parameters_layout):
        # Add Profiles and keep zoom options
        self.display_profiles = QtWidgets.QCheckBox(&#34;Profiles&#34;)
        self.display_profiles.stateChanged.connect(self.toggle_display_profiles)
        self.display_profiles.setChecked(False)
        parameters_layout.addWidget(self.display_profiles)
        self.keep_zoom = QtWidgets.QCheckBox(&#34;Keep zoom&#34;)
        self.keep_zoom.setChecked(False)
        parameters_layout.addWidget(self.keep_zoom)

        # Reset button
        self.reset_button = QtWidgets.QPushButton(&#34;reset&#34;)
        parameters_layout.addWidget(self.reset_button)
        self.reset_button.clicked.connect(self.reset_intensities)

        # Add color difference slider
        self.filter_params_gui.add_imdiff_factor(parameters_layout, self.update_image_intensity_event)

        # --- Saturation adjustment
        self.filter_params_gui.add_saturation(parameters_layout, self.update_image_intensity_event)
        # --- Black point adjustment
        self.filter_params_gui.add_blackpoint(parameters_layout, self.update_image_intensity_event)
        # --- white point adjustment
        self.filter_params_gui.add_whitepoint(parameters_layout, self.update_image_intensity_event)
        # --- Gamma adjustment
        self.filter_params_gui.add_gamma(parameters_layout, self.update_image_intensity_event)

    def layout_parameters_2(self, parameters2_layout):
        # --- G_R adjustment
        self.filter_params_gui.add_g_r(parameters2_layout, self.update_image_intensity_event)
        # --- G_B adjustment
        self.filter_params_gui.add_g_b(parameters2_layout, self.update_image_intensity_event)

    def update_layout(self):
        self.print_log(&#34;update_layout&#34;)
        vertical_layout = QtWidgets.QVBoxLayout()
        self.layout_buttons(vertical_layout)

        # First line of parameter control
        parameters_layout = QtWidgets.QHBoxLayout()
        self.layout_parameters(parameters_layout)
        vertical_layout.addLayout(parameters_layout, 1)

        # Second line of parameter control
        parameters2_layout = QtWidgets.QHBoxLayout()
        self.layout_parameters_2(parameters2_layout)
        vertical_layout.addLayout(parameters2_layout, 1)

        self.viewer_grid_layout = QtWidgets.QGridLayout()
        self.viewer_grid_layout.setHorizontalSpacing(1)
        self.viewer_grid_layout.setVerticalSpacing(1)
        self.set_number_of_viewers(1)
        vertical_layout.addLayout(self.viewer_grid_layout, 1)

        self.figures_widget = QtWidgets.QWidget()
        self.figures_layout = QtWidgets.QHBoxLayout()
        self.figures_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        # for the moment ignore this
        # self.figures_layout.addWidget(self.value_in_range_canvas)
        # self.figures_widget.setLayout(self.figures_layout)

        vertical_layout.addWidget(self.figures_widget)
        self.toggle_display_profiles()
        self.setLayout(vertical_layout)
        print(&#34;update_layout done&#34;)

    def toggle_display_profiles(self):
        self.figures_widget.setVisible(self.display_profiles.isChecked())
        self.update_image()

    def get_output_image(self, im_string_id):
        &#34;&#34;&#34;
        Search for the image with given label in the current row
        if not in cache reads it and add it to the cache
        :param im_string_id: string that identifies the image to display
        :return:
        &#34;&#34;&#34;
        # print(f&#34;get_output_image({im_string_id}) &#34;)
        start = get_time()

        image_filename = self.image_dict[im_string_id]
        image_transform = None
        self.print_log(f&#34;MultiView.get_output_image() image_filename:{image_filename}&#34;)

        image_data, _ = self.cache.get_image(image_filename, self.read_size, verbose=self.show_timing_detailed(),
                                             use_RGB=not self.use_opengl, image_transform=image_transform)

        if image_data is not None:
            self.output_image_label[im_string_id] = image_filename
            output_image = image_data
        else:
            print(f&#34;failed to get image {im_string_id}: {image_filename}&#34;)
            return None

        if self.show_timing_detailed():
            print(f&#34; get_output_image took {int((get_time() - start)*1000+0.5)} ms&#34;.format)

        # force image bayer information if selected from menu
        res = output_image
        set_bayer = self.raw_bayer[self.current_raw_bayer]
        if res.channels in [ImageFormat.CH_BGGR, ImageFormat.CH_GBRG, ImageFormat.CH_GRBG, ImageFormat.CH_RGGB] and set_bayer is not None:
            print(f&#34;Setting bayer {set_bayer}&#34;)
            res.channels = set_bayer

        return res

    def set_message_callback(self, message_cb):
        self.message_cb = message_cb

    def setMessage(self, mess):
        if self.message_cb is not None:
            self.message_cb(mess)

    def cache_read_images(self, image_filenames: List[str], reload: bool =False) -&gt; None:
        &#34;&#34;&#34; Read the list of images into the cache, with option to reload them from disk

        Args:
            image_filenames (List[str]): list of image filenames
            reload (bool, optional): reload removes first the images from the ImageCache 
                before adding them. Defaults to False.
        &#34;&#34;&#34;        
        # print(f&#34;cache_read_images({image_filenames}) &#34;)
        image_transform = None
        if reload:
            for f in image_filenames:
                self.cache.remove(f)
        self.cache.add_images(image_filenames, self.read_size, verbose=False, use_RGB=not self.use_opengl,
                             image_transform=image_transform)

    def update_label_fonts(self):
        # Update selected image label, we could do it later too
        for im_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if im_name != &#39;none&#39;:
                is_bold      = im_name == self.output_label_current_image
                is_underline = im_name == self.output_label_reference_image
                is_bold |= is_underline
                self.bold_font.setBold(is_bold)
                self.bold_font.setUnderline(is_underline)
                self.bold_font.setPointSize(8)
                self.label[im_name].setFont(self.bold_font)
                self.label[im_name].setWordWrap(True)
            # self.label[im_name].setMaximumWidth(160)

    def update_image(self, image_name=None, reload=False):
        &#34;&#34;&#34;
        Uses the variable self.output_label_current_image
        :return:
        &#34;&#34;&#34;
        self.print_log(&#39;update_image {} current: {}&#39;.format(image_name, self.output_label_current_image))
        update_image_start = get_time()

        # Define the current selected image
        if image_name is not None:
            self.output_label_current_image = image_name
        if self.output_label_current_image == &#34;&#34;:
            return

        if self.image_dict[self.output_label_current_image] is None:
            print(&#34; No image filename for current image&#34;)
            return

        self.update_label_fonts()

        # find first active window
        first_active_window = 0
        for n in range(self.nb_viewers_used):
            self.image_viewers[n].display_timing = self.show_timing()&gt;0
            if self.image_viewers[n].is_active():
                first_active_window = n
                break

        # Read images in parallel to improve preformances
        # list all required image filenames
        # set all viewers image names (labels)
        image_filenames = [self.image_dict[self.output_label_current_image]]
        # define image associated to each used viewer and add it to the list of images to get
        for n in range(self.nb_viewers_used):
            viewer : ImageViewer = self.image_viewers[n]
            # Set active only the first active window
            viewer.set_active(n == first_active_window)
            if viewer.get_image() is None:
                if n &lt; len(self.image_list):
                    viewer.image_name = self.image_list[n]
                    image_filenames.append(self.image_dict[self.image_list[n]])
                else:
                    viewer.image_name = self.output_label_current_image
            else:
                # image_name should belong to image_dict
                if viewer.image_name in self.image_dict:
                    image_filenames.append(self.image_dict[viewer.image_name])
                else:
                    viewer.image_name = self.output_label_current_image

        # remove duplicates
        image_filenames = list(set(image_filenames))
        # print(f&#34;image filenames {image_filenames}&#34;)
        self.cache_read_images(image_filenames, reload=reload)

        try:
            current_image = self.get_output_image(self.output_label_current_image)
            if current_image is None:
                return
        except Exception as e:
            print(&#34;Error: failed to get image {}: {}&#34;.format(self.output_label_current_image, e))
            return

        # print(f&#34;cur {self.output_label_current_image}&#34;)
        current_filename = self.output_image_label[self.output_label_current_image]

        if self.show_timing_detailed():
            time_spent = get_time() - update_image_start

        self.setMessage(&#34;Image: {0}&#34;.format(current_filename))

        current_viewer = self.image_viewers[first_active_window]
        if self.save_image_clipboard:
            print(&#34;set save image to clipboard&#34;)
            current_viewer.set_clipboard(self.clip, True)
        current_viewer.set_active(True)
        current_viewer.image_name = self.output_label_current_image
        current_viewer.set_image(current_image)
        if self.save_image_clipboard:
            print(&#34;end save image to clipboard&#34;)
            current_viewer.set_clipboard(None, False)

        # print(f&#34;ref {self.output_label_reference_image}&#34;)
        if self.output_label_reference_image==self.output_label_current_image:
            reference_image = current_image
        else:
            reference_image = self.get_output_image(self.output_label_reference_image)

        if self.nb_viewers_used &gt;= 2:
            prev_n = first_active_window
            for n in range(1, self.nb_viewers_used):
                n1 = (first_active_window + n) % self.nb_viewers_used
                viewer = self.image_viewers[n1]
                # viewer image has already been defined
                # try to update corresponding images in row
                try:
                    viewer_image = self.get_output_image(viewer.image_name)
                except Exception as e:
                    print(&#34;Error: failed to get image {}: {}&#34;.format(viewer.image_name, e))
                    viewer.set_image(current_image)
                else:
                    viewer.set_image(viewer_image)

                # set reference image
                viewer.set_image_ref(reference_image)

                self.image_viewers[prev_n].set_synchronize(viewer)
                prev_n = n1
            # Create a synchronization loop
            if prev_n != first_active_window:
                self.image_viewers[prev_n].set_synchronize(self.image_viewers[first_active_window])

        # Be sure to show the required viewers
        for n in range(self.nb_viewers_used):
            viewer = self.image_viewers[n]
            # print(f&#34;show viewer {n}&#34;)
            # Note: calling show in any case seems to avoid double calls to paint event that update() triggers
            # viewer.show()
            if viewer.isHidden():
                # print(f&#34;show viewer {n}&#34;)
                viewer.show()
            else:
                # print(f&#34;update viewer {n}&#34;)
                viewer.update()


        # self.image_scroll_area.adjustSize()
        # if self.show_timing():
        print(f&#34; Update image took {(get_time() - update_image_start)*1000:0.0f} ms&#34;)

    def set_number_of_viewers(self, nb_viewers: int = 1, max_columns : int = 0) -&gt; None:
        self.print_log(&#34;*** set_number_of_viewers()&#34;)

        # 1. remove current viewers from grid layout
        # self.viewer_grid_layout.hide()
        for v in self.image_viewers:
            v.hide()
            self.viewer_grid_layout.removeWidget(v)

        self.nb_viewers_used : int = nb_viewers
        print(f&#34;max_columns = {max_columns}&#34;)
        if max_columns&gt;0:
            row_length = min(self.nb_viewers_used, max_columns)
            col_length = int(math.ceil(self.nb_viewers_used / row_length))
        else:
            # Find best configuration to fill the space based on image size and widget size?
            col_length = int(math.sqrt(self.nb_viewers_used))
            row_length = int(math.ceil(self.nb_viewers_used / col_length))
        self.print_log(&#39;col_length = {} row_length = {}&#39;.format(col_length, row_length))
        # be sure to have enough image viewers allocated
        while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
            viewer = self.image_viewer_class()
            viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
            self.allocated_image_viewers.append(viewer)

        self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]

        for n in range(self.nb_viewers_used):
            self.viewer_grid_layout.addWidget(self.image_viewers[n], int(n / float(row_length)), n % row_length)
            self.image_viewers[n].hide()

        # for n in range(self.nb_viewers_used):
        #     print(&#34;Viewer {} size {}&#34;.format(n, (self.image_viewers[n].width(), self.image_viewers[n].height())))

    def set_number_of_viewers_callback(self):
        self.set_number_of_viewers()
        self.viewer_grid_layout.update()
        self.update_image()

    def keyReleaseEvent(self, event):
        if type(event) == QtGui.QKeyEvent:
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
            if modifiers &amp; (QtCore.Qt.AltModifier | QtCore.Qt.ControlModifier):
                event.accept()
            # else:
            #     try:
            #         # reset reference image
            #         if self.output_label_current_image != self.output_label_reference_image:
            #             self.update_image(self.output_label_reference_image)
            #     except Exception as e:
            #         print(&#34; Error: {}&#34;.format(e))

    def find_in_layout(self, layout: QtWidgets.QLayout) -&gt; Optional[QtWidgets.QLayout]:
        &#34;&#34;&#34; Search Recursivement in Layouts for the current widget

        Args:
            layout (QtWidgets.QLayout): input layout for search

        Returns:
            layout containing the current widget or None if not found
        &#34;&#34;&#34;
        print(&#34;find_in_layout()&#34;)
        if layout.indexOf(self) != -1: return layout
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item.widget() == self: return layout
            if (l := item.layout()) and (found:=self.find_in_layout(l)): return l
        print(&#34;find_in_layout() return None&#34;)
        return None

    def toggle_fullscreen(self, event):
        print(f&#34;toggle_fullscreen&#34;)
        if not issubclass(self.__class__,QtWidgets.QWidget):
            print(f&#34;Cannot use toggle_fullscreen on a class that is not a QWidget&#34;)
            return
        # Should be inside a layout
        if self.before_max_parent is None:
            print(f&#34;self.parent() is not None {self.parent() is not None}&#34;)
            print(f&#34;self.parent().layout() {self.parent().layout()} &#34;)
            if self.parent() is not None and (playout := self.parent().layout()) is not None:
                if self.find_in_layout(playout):
                    self.before_max_parent = self.parent()
                    self.replacing_widget = QtWidgets.QWidget(self.before_max_parent)
                    self.parent().layout().replaceWidget(self, self.replacing_widget)
                    # We need to go up from the parent widget to the main window to get its geometry
                    # so that the fullscreen is display on the same monitor
                    toplevel_parent : Optional[QtWidgets.QWidget] = self.parentWidget()
                    while toplevel_parent.parentWidget(): toplevel_parent = toplevel_parent.parentWidget()
                    self.setParent(None)
                    if toplevel_parent: self.setGeometry(toplevel_parent.geometry())
                    self.showFullScreen()
                    event.accept()
                    return
        if self.before_max_parent is not None:
            self.setParent(self.before_max_parent)
            self.parent().layout().replaceWidget(self.replacing_widget, self)
            self.replacing_widget = self.before_max_parent = None
            # self.resize(self.before_max_size)
            self.show()
            self.parent().update()
            self.setFocus()
            event.accept()
            return



    def keyPressEvent(self, event):
        if type(event) == QtGui.QKeyEvent:
            # print(&#34;key is &#34;, event.key())
            self.print_log(f&#34; QKeySequence() {QtGui.QKeySequence(event.key()).toString()}&#34;)
            # print( QtGui.QKeySequence(event.key()).toString())
            # print(f&#34; capslock: {event.getModifierState(&#39;CapsLock&#39;)}&#34;)
            if self.show_trace():
                print(&#34;key is &#34;, event.key())
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            # F1: open help in browser
            if event.key() == QtCore.Qt.Key_F1:
                import qimview
                mb = QtWidgets.QMessageBox(self)
                mb.setWindowTitle(f&#34;qimview {qimview.__version__}: MultiView help&#34;)
                mb.setTextFormat(QtCore.Qt.TextFormat.RichText)
                mb.setText(
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki&#39;&gt;qimview&lt;/a&gt;&lt;br&gt;&#34;
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/4.-Multi%E2%80%90image-viewer&#39;&gt;MultiImage Viewer&lt;/a&gt;&lt;br&gt;&#34;
                    &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/3.-Image-Viewers&#39;&gt;Image Viewer&lt;/a&gt;&#34;)
                mb.exec()
                event.accept()
                return

            # F5: reload images
            if event.key() == QtCore.Qt.Key_F5:
                self.update_image(reload=True)
                event.accept()
                return

            if event.key() == QtCore.Qt.Key_F11:
                # Should be inside a layout
                print(&#34;MultiView F11 pressed&#34;)
                self.toggle_fullscreen(event)
                return

            # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
            if modifiers &amp; QtCore.Qt.AltModifier:
                for n in range(len(self.image_list)):
                    if self.image_list[n] is not None:
                        if event.key() == QtCore.Qt.Key_0 + n:
                            if self.output_label_current_image != self.image_list[n]:
                                # with Alt+Ctrl, change reference image
                                # if modifiers &amp; QtCore.Qt.ControlModifier:
                                #     self.set_reference_label(self.image_list[n])
                                self.update_image(self.image_list[n])
                                self.setFocus()
                                return
                event.accept()
                return

            if event.modifiers() &amp; QtCore.Qt.ControlModifier:
                # allow to switch between images by pressing Ctrl+&#39;image position&#39; (Ctrl+0, Ctrl+1, etc)
                for n in range(len(self.image_list)):
                    if self.image_list[n] != &#39;none&#39;:
                        if event.key() == QtCore.Qt.Key_0 + n:
                            if self.output_label_current_image != self.image_list[n]:
                                self.set_reference_label(self.image_list[n], update_viewers=True)
                                self.update_image()
                                event.accept()
                                return
                return
            # print(f&#34;event.modifiers {event.modifiers()}&#34;)
            # if not event.modifiers():
            for n in range(1, 10):
                if event.key() == QtCore.Qt.Key_0 + n:
                    self.set_number_of_viewers(n)
                    self.viewer_grid_layout.update()
                    self.update_image()
                    self.setFocus()
                    event.accept()
                    return

            if event.key() == QtCore.Qt.Key_Up:
                if self.key_up_callback is not None:
                    self.key_up_callback()
                event.accept()
                return

            if event.key() == QtCore.Qt.Key_Down:
                if self.key_down_callback is not None:
                    self.key_down_callback()
                event.accept()
                return

            nb_images = len(self.image_list)
            if event.key() == QtCore.Qt.Key_Left:
                for n in range(nb_images):
                    if self.output_label_current_image == self.image_list[n]:
                        print(f&#34;setting new image index {(n+nb_images-1)%nb_images}&#34;)
                        self.update_image(self.image_list[(n+nb_images-1)%nb_images])
                        event.accept()
                        return

            if event.key() == QtCore.Qt.Key_Right:
                for n in range(nb_images):
                    if self.output_label_current_image == self.image_list[n]:
                        print(f&#34;setting new image index {(n+nb_images+1)%nb_images}&#34;)
                        self.update_image(self.image_list[(n+1)%nb_images])
                        event.accept()
                        return
                
            # G: display number of columns
            if event.key() == QtCore.Qt.Key_G:
                self.max_columns = int ((self.max_columns + 1) % self.nb_viewers_used + 1)
                self.set_number_of_viewers(self.nb_viewers_used, max_columns=self.max_columns)
                self.update_image(reload=True)
                self.setFocus()
                event.accept()
                return

        else:
            event.ignore()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PySide6.QtWidgets.QWidget</li>
<li>PySide6.QtCore.QObject</li>
<li>PySide6.QtGui.QPaintDevice</li>
<li>Shiboken.Object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qimview.image_viewers.MultiView.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qimview.image_viewers.MultiView.add_context_menu"><code class="name flex">
<span>def <span class="ident">add_context_menu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_context_menu(self):
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.show_context_menu)
    self._context_menu = QtWidgets.QMenu()
    self.viewer_modes = {}
    for v in ViewerType:
        self.viewer_modes[v.name] = v
    self._default_viewer_mode = ViewerType.QT_VIEWER.name
    self.viewer_mode_selection = MenuSelection(&#34;Viewer mode&#34;, 
        self._context_menu, self.viewer_modes, self._default_viewer_mode, self.update_viewer_mode)
    self._context_menu.addSeparator()
    action = self._context_menu.addAction(&#34;Reset viewers&#34;)
    action.triggered.connect(self.reset_viewers)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.cache_read_images"><code class="name flex">
<span>def <span class="ident">cache_read_images</span></span>(<span>self, image_filenames: List[str], reload: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Read the list of images into the cache, with option to reload them from disk</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image_filenames</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>list of image filenames</dd>
<dt><strong><code>reload</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>reload removes first the images from the ImageCache
before adding them. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_read_images(self, image_filenames: List[str], reload: bool =False) -&gt; None:
    &#34;&#34;&#34; Read the list of images into the cache, with option to reload them from disk

    Args:
        image_filenames (List[str]): list of image filenames
        reload (bool, optional): reload removes first the images from the ImageCache 
            before adding them. Defaults to False.
    &#34;&#34;&#34;        
    # print(f&#34;cache_read_images({image_filenames}) &#34;)
    image_transform = None
    if reload:
        for f in image_filenames:
            self.cache.remove(f)
    self.cache.add_images(image_filenames, self.read_size, verbose=False, use_RGB=not self.use_opengl,
                         image_transform=image_transform)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.check_verbosity"><code class="name flex">
<span>def <span class="ident">check_verbosity</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_verbosity(self, flag):
    return self.verbosity &amp; flag</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.clear_buttons"><code class="name flex">
<span>def <span class="ident">clear_buttons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_buttons(self):
    if self.button_layout is not None:
        # start clearing the layout
        # for i in range(self.button_layout.count()): self.button_layout.itemAt(i).widget().close()
        self.print_log(f&#34;MultiView.clear_buttons() {self.image_list}&#34;)
        for image_name in reversed(self.image_list):
            if image_name in self.label:
                self.button_layout.removeWidget(self.label[image_name])
                self.label[image_name].close()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.create_buttons"><code class="name flex">
<span>def <span class="ident">create_buttons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_buttons(self):
    if self.button_layout is not None:
        max_grid_columns = 10
        idx = 0
        for image_name in self.image_list:
            # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
            if image_name != &#39;none&#39;:
                self.button_layout.addWidget(self.label[image_name], idx // max_grid_columns, idx % max_grid_columns)
                idx += 1</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.find_in_layout"><code class="name flex">
<span>def <span class="ident">find_in_layout</span></span>(<span>self, layout: PySide6.QtWidgets.QLayout) ‑> Optional[PySide6.QtWidgets.QLayout]</span>
</code></dt>
<dd>
<div class="desc"><p>Search Recursivement in Layouts for the current widget</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>QtWidgets.QLayout</code></dt>
<dd>input layout for search</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>layout containing the current widget or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_in_layout(self, layout: QtWidgets.QLayout) -&gt; Optional[QtWidgets.QLayout]:
    &#34;&#34;&#34; Search Recursivement in Layouts for the current widget

    Args:
        layout (QtWidgets.QLayout): input layout for search

    Returns:
        layout containing the current widget or None if not found
    &#34;&#34;&#34;
    print(&#34;find_in_layout()&#34;)
    if layout.indexOf(self) != -1: return layout
    for i in range(layout.count()):
        item = layout.itemAt(i)
        if item.widget() == self: return layout
        if (l := item.layout()) and (found:=self.find_in_layout(l)): return l
    print(&#34;find_in_layout() return None&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.get_output_image"><code class="name flex">
<span>def <span class="ident">get_output_image</span></span>(<span>self, im_string_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the image with given label in the current row
if not in cache reads it and add it to the cache
:param im_string_id: string that identifies the image to display
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_image(self, im_string_id):
    &#34;&#34;&#34;
    Search for the image with given label in the current row
    if not in cache reads it and add it to the cache
    :param im_string_id: string that identifies the image to display
    :return:
    &#34;&#34;&#34;
    # print(f&#34;get_output_image({im_string_id}) &#34;)
    start = get_time()

    image_filename = self.image_dict[im_string_id]
    image_transform = None
    self.print_log(f&#34;MultiView.get_output_image() image_filename:{image_filename}&#34;)

    image_data, _ = self.cache.get_image(image_filename, self.read_size, verbose=self.show_timing_detailed(),
                                         use_RGB=not self.use_opengl, image_transform=image_transform)

    if image_data is not None:
        self.output_image_label[im_string_id] = image_filename
        output_image = image_data
    else:
        print(f&#34;failed to get image {im_string_id}: {image_filename}&#34;)
        return None

    if self.show_timing_detailed():
        print(f&#34; get_output_image took {int((get_time() - start)*1000+0.5)} ms&#34;.format)

    # force image bayer information if selected from menu
    res = output_image
    set_bayer = self.raw_bayer[self.current_raw_bayer]
    if res.channels in [ImageFormat.CH_BGGR, ImageFormat.CH_GBRG, ImageFormat.CH_GRBG, ImageFormat.CH_RGGB] and set_bayer is not None:
        print(f&#34;Setting bayer {set_bayer}&#34;)
        res.channels = set_bayer

    return res</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.keyPressEvent"><code class="name flex">
<span>def <span class="ident">keyPressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>keyPressEvent(self, event: PySide6.QtGui.QKeyEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyPressEvent(self, event):
    if type(event) == QtGui.QKeyEvent:
        # print(&#34;key is &#34;, event.key())
        self.print_log(f&#34; QKeySequence() {QtGui.QKeySequence(event.key()).toString()}&#34;)
        # print( QtGui.QKeySequence(event.key()).toString())
        # print(f&#34; capslock: {event.getModifierState(&#39;CapsLock&#39;)}&#34;)
        if self.show_trace():
            print(&#34;key is &#34;, event.key())
        modifiers = QtWidgets.QApplication.keyboardModifiers()
        # F1: open help in browser
        if event.key() == QtCore.Qt.Key_F1:
            import qimview
            mb = QtWidgets.QMessageBox(self)
            mb.setWindowTitle(f&#34;qimview {qimview.__version__}: MultiView help&#34;)
            mb.setTextFormat(QtCore.Qt.TextFormat.RichText)
            mb.setText(
                &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki&#39;&gt;qimview&lt;/a&gt;&lt;br&gt;&#34;
                &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/4.-Multi%E2%80%90image-viewer&#39;&gt;MultiImage Viewer&lt;/a&gt;&lt;br&gt;&#34;
                &#34;&lt;a href=&#39;https://github.com/qimview/qimview/wiki/3.-Image-Viewers&#39;&gt;Image Viewer&lt;/a&gt;&#34;)
            mb.exec()
            event.accept()
            return

        # F5: reload images
        if event.key() == QtCore.Qt.Key_F5:
            self.update_image(reload=True)
            event.accept()
            return

        if event.key() == QtCore.Qt.Key_F11:
            # Should be inside a layout
            print(&#34;MultiView F11 pressed&#34;)
            self.toggle_fullscreen(event)
            return

        # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
        if modifiers &amp; QtCore.Qt.AltModifier:
            for n in range(len(self.image_list)):
                if self.image_list[n] is not None:
                    if event.key() == QtCore.Qt.Key_0 + n:
                        if self.output_label_current_image != self.image_list[n]:
                            # with Alt+Ctrl, change reference image
                            # if modifiers &amp; QtCore.Qt.ControlModifier:
                            #     self.set_reference_label(self.image_list[n])
                            self.update_image(self.image_list[n])
                            self.setFocus()
                            return
            event.accept()
            return

        if event.modifiers() &amp; QtCore.Qt.ControlModifier:
            # allow to switch between images by pressing Ctrl+&#39;image position&#39; (Ctrl+0, Ctrl+1, etc)
            for n in range(len(self.image_list)):
                if self.image_list[n] != &#39;none&#39;:
                    if event.key() == QtCore.Qt.Key_0 + n:
                        if self.output_label_current_image != self.image_list[n]:
                            self.set_reference_label(self.image_list[n], update_viewers=True)
                            self.update_image()
                            event.accept()
                            return
            return
        # print(f&#34;event.modifiers {event.modifiers()}&#34;)
        # if not event.modifiers():
        for n in range(1, 10):
            if event.key() == QtCore.Qt.Key_0 + n:
                self.set_number_of_viewers(n)
                self.viewer_grid_layout.update()
                self.update_image()
                self.setFocus()
                event.accept()
                return

        if event.key() == QtCore.Qt.Key_Up:
            if self.key_up_callback is not None:
                self.key_up_callback()
            event.accept()
            return

        if event.key() == QtCore.Qt.Key_Down:
            if self.key_down_callback is not None:
                self.key_down_callback()
            event.accept()
            return

        nb_images = len(self.image_list)
        if event.key() == QtCore.Qt.Key_Left:
            for n in range(nb_images):
                if self.output_label_current_image == self.image_list[n]:
                    print(f&#34;setting new image index {(n+nb_images-1)%nb_images}&#34;)
                    self.update_image(self.image_list[(n+nb_images-1)%nb_images])
                    event.accept()
                    return

        if event.key() == QtCore.Qt.Key_Right:
            for n in range(nb_images):
                if self.output_label_current_image == self.image_list[n]:
                    print(f&#34;setting new image index {(n+nb_images+1)%nb_images}&#34;)
                    self.update_image(self.image_list[(n+1)%nb_images])
                    event.accept()
                    return
            
        # G: display number of columns
        if event.key() == QtCore.Qt.Key_G:
            self.max_columns = int ((self.max_columns + 1) % self.nb_viewers_used + 1)
            self.set_number_of_viewers(self.nb_viewers_used, max_columns=self.max_columns)
            self.update_image(reload=True)
            self.setFocus()
            event.accept()
            return

    else:
        event.ignore()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.keyReleaseEvent"><code class="name flex">
<span>def <span class="ident">keyReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>keyReleaseEvent(self, event: PySide6.QtGui.QKeyEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyReleaseEvent(self, event):
    if type(event) == QtGui.QKeyEvent:
        modifiers = QtWidgets.QApplication.keyboardModifiers()
        # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
        if modifiers &amp; (QtCore.Qt.AltModifier | QtCore.Qt.ControlModifier):
            event.accept()
        # else:
        #     try:
        #         # reset reference image
        #         if self.output_label_current_image != self.output_label_reference_image:
        #             self.update_image(self.output_label_reference_image)
        #     except Exception as e:
        #         print(&#34; Error: {}&#34;.format(e))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.layout_buttons"><code class="name flex">
<span>def <span class="ident">layout_buttons</span></span>(<span>self, vertical_layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layout_buttons(self, vertical_layout):
    self.button_widget = QtWidgets.QWidget(self)
    self.button_layout = QtWidgets.QGridLayout()
    self.button_layout.setHorizontalSpacing(0)
    self.button_layout.setVerticalSpacing(0)
    # button_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
    self.create_buttons()
    vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
    # vertical_layout.setSizeConstraint(QtWidgets.QLayout.SetNoConstraint)
    self.button_widget.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
    self.button_widget.setLayout(self.button_layout)
    vertical_layout.addWidget(self.button_widget, 0, QtCore.Qt.AlignTop)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.layout_parameters"><code class="name flex">
<span>def <span class="ident">layout_parameters</span></span>(<span>self, parameters_layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layout_parameters(self, parameters_layout):
    # Add Profiles and keep zoom options
    self.display_profiles = QtWidgets.QCheckBox(&#34;Profiles&#34;)
    self.display_profiles.stateChanged.connect(self.toggle_display_profiles)
    self.display_profiles.setChecked(False)
    parameters_layout.addWidget(self.display_profiles)
    self.keep_zoom = QtWidgets.QCheckBox(&#34;Keep zoom&#34;)
    self.keep_zoom.setChecked(False)
    parameters_layout.addWidget(self.keep_zoom)

    # Reset button
    self.reset_button = QtWidgets.QPushButton(&#34;reset&#34;)
    parameters_layout.addWidget(self.reset_button)
    self.reset_button.clicked.connect(self.reset_intensities)

    # Add color difference slider
    self.filter_params_gui.add_imdiff_factor(parameters_layout, self.update_image_intensity_event)

    # --- Saturation adjustment
    self.filter_params_gui.add_saturation(parameters_layout, self.update_image_intensity_event)
    # --- Black point adjustment
    self.filter_params_gui.add_blackpoint(parameters_layout, self.update_image_intensity_event)
    # --- white point adjustment
    self.filter_params_gui.add_whitepoint(parameters_layout, self.update_image_intensity_event)
    # --- Gamma adjustment
    self.filter_params_gui.add_gamma(parameters_layout, self.update_image_intensity_event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.layout_parameters_2"><code class="name flex">
<span>def <span class="ident">layout_parameters_2</span></span>(<span>self, parameters2_layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layout_parameters_2(self, parameters2_layout):
    # --- G_R adjustment
    self.filter_params_gui.add_g_r(parameters2_layout, self.update_image_intensity_event)
    # --- G_B adjustment
    self.filter_params_gui.add_g_b(parameters2_layout, self.update_image_intensity_event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.make_mouse_double_click"><code class="name flex">
<span>def <span class="ident">make_mouse_double_click</span></span>(<span>self, image_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_mouse_double_click(self, image_name):
    def mouse_double_click(obj, event):
        &#39;&#39;&#39;
        Sets the double clicked label as the reference image
        :param obj:
        :param event:
        &#39;&#39;&#39;
        print(&#39;mouse_double_click {}&#39;.format(image_name))
        obj.output_label_reference_image = image_name
        obj.output_label_current_image = obj.output_label_reference_image
        obj.update_image()

    return types.MethodType(mouse_double_click, self)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.make_mouse_press"><code class="name flex">
<span>def <span class="ident">make_mouse_press</span></span>(<span>self, image_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_mouse_press(self, image_name):
    def mouse_press(obj, event):
        print(&#39;mouse_press&#39;)
        obj.update_image(image_name)

    return types.MethodType(mouse_press, self)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.mouse_release"><code class="name flex">
<span>def <span class="ident">mouse_release</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouse_release(self, event):
    self.update_image(self.output_label_reference_image)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.print_log"><code class="name flex">
<span>def <span class="ident">print_log</span></span>(<span>self, mess)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_log(self, mess):
    if self.verbosity &amp; self.verbosity_LIGHT:
        print(mess)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.reset_intensities"><code class="name flex">
<span>def <span class="ident">reset_intensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_intensities(self):
    self.filter_params_gui.reset_all()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.reset_viewers"><code class="name flex">
<span>def <span class="ident">reset_viewers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_viewers(self):
    for v in self.image_viewers:
        v.hide()
        self.viewer_grid_layout.removeWidget(v)
    self.allocated_image_viewers.clear()
    self.image_viewers.clear()
    # Create viewer instances
    for n in range(self.nb_viewers_used):
        viewer = self.image_viewer_class()
        viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.allocated_image_viewers.append(viewer)
        self.image_viewers.append(viewer)
    self.set_number_of_viewers(self.nb_viewers_used)
    self.viewer_grid_layout.update()
    self.update_image()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.setMessage"><code class="name flex">
<span>def <span class="ident">setMessage</span></span>(<span>self, mess)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMessage(self, mess):
    if self.message_cb is not None:
        self.message_cb(mess)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_cache_memory_bar"><code class="name flex">
<span>def <span class="ident">set_cache_memory_bar</span></span>(<span>self, progress_bar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cache_memory_bar(self, progress_bar):
    self.cache.set_memory_bar(progress_bar)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_images"><code class="name flex">
<span>def <span class="ident">set_images</span></span>(<span>self, images, set_viewers=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_images(self, images, set_viewers=False):
    self.print_log(f&#34;MultiView.set_images() {images}&#34;)
    if images.keys() == self.image_dict.keys():
        self.image_dict = images
        self.update_reference()
    else:
        self.image_dict = images
        self.update_image_buttons()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_key_down_callback"><code class="name flex">
<span>def <span class="ident">set_key_down_callback</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_key_down_callback(self, c):
    self.key_down_callback = c</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_key_up_callback"><code class="name flex">
<span>def <span class="ident">set_key_up_callback</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_key_up_callback(self, c):
    self.key_up_callback = c</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_message_callback"><code class="name flex">
<span>def <span class="ident">set_message_callback</span></span>(<span>self, message_cb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_message_callback(self, message_cb):
    self.message_cb = message_cb</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_number_of_viewers"><code class="name flex">
<span>def <span class="ident">set_number_of_viewers</span></span>(<span>self, nb_viewers: int = 1, max_columns: int = 0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_number_of_viewers(self, nb_viewers: int = 1, max_columns : int = 0) -&gt; None:
    self.print_log(&#34;*** set_number_of_viewers()&#34;)

    # 1. remove current viewers from grid layout
    # self.viewer_grid_layout.hide()
    for v in self.image_viewers:
        v.hide()
        self.viewer_grid_layout.removeWidget(v)

    self.nb_viewers_used : int = nb_viewers
    print(f&#34;max_columns = {max_columns}&#34;)
    if max_columns&gt;0:
        row_length = min(self.nb_viewers_used, max_columns)
        col_length = int(math.ceil(self.nb_viewers_used / row_length))
    else:
        # Find best configuration to fill the space based on image size and widget size?
        col_length = int(math.sqrt(self.nb_viewers_used))
        row_length = int(math.ceil(self.nb_viewers_used / col_length))
    self.print_log(&#39;col_length = {} row_length = {}&#39;.format(col_length, row_length))
    # be sure to have enough image viewers allocated
    while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
        viewer = self.image_viewer_class()
        viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.allocated_image_viewers.append(viewer)

    self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]

    for n in range(self.nb_viewers_used):
        self.viewer_grid_layout.addWidget(self.image_viewers[n], int(n / float(row_length)), n % row_length)
        self.image_viewers[n].hide()

    # for n in range(self.nb_viewers_used):
    #     print(&#34;Viewer {} size {}&#34;.format(n, (self.image_viewers[n].width(), self.image_viewers[n].height())))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_number_of_viewers_callback"><code class="name flex">
<span>def <span class="ident">set_number_of_viewers_callback</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_number_of_viewers_callback(self):
    self.set_number_of_viewers()
    self.viewer_grid_layout.update()
    self.update_image()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_read_size"><code class="name flex">
<span>def <span class="ident">set_read_size</span></span>(<span>self, read_size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_read_size(self, read_size):
    self.read_size = read_size
    # reset cache
    self.cache.reset()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_reference_label"><code class="name flex">
<span>def <span class="ident">set_reference_label</span></span>(<span>self, ref: str, update_viewers=False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_reference_label(self, ref: str, update_viewers=False) -&gt; None:
    try:
        if ref is not None:
            if ref!=self.output_label_reference_image:
                self.output_label_reference_image = ref
                if update_viewers:
                    self.update_reference()
    except Exception as e:
        print(f&#39; Failed to set reference label {e}&#39;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_verbosity"><code class="name flex">
<span>def <span class="ident">set_verbosity</span></span>(<span>self, flag, enable=True)</span>
</code></dt>
<dd>
<div class="desc"><p>:param v: verbosity flags
:param b: boolean to enable or disable flag
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_verbosity(self, flag, enable=True):
    &#34;&#34;&#34;
    :param v: verbosity flags
    :param b: boolean to enable or disable flag
    :return:
    &#34;&#34;&#34;
    if enable:
        self.verbosity = self.verbosity | flag
    else:
        self.verbosity = self.verbosity &amp; ~flag</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.set_viewer_images"><code class="name flex">
<span>def <span class="ident">set_viewer_images</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set viewer images based on self.image_dict.keys()
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_viewer_images(self):
    &#34;&#34;&#34;
    Set viewer images based on self.image_dict.keys()
    :return:
    &#34;&#34;&#34;
    # if set_viewers, we force the viewer layout and images based on the list
    # be sure to have enough image viewers allocated
    while self.nb_viewers_used &gt; len(self.allocated_image_viewers):
        viewer = self.image_viewer_class()
        viewer.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.allocated_image_viewers.append(viewer)
    self.image_viewers = self.allocated_image_viewers[:self.nb_viewers_used]
    image_names = list(self.image_dict.keys())
    for n in range(self.nb_viewers_used):
        if n &lt; len(image_names):
            self.image_viewers[n].image_name = image_names[n]
        else:
            self.image_viewers[n].image_name = image_names[len(image_names)-1]</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.show_context_menu"><code class="name flex">
<span>def <span class="ident">show_context_menu</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_context_menu(self, pos):
    # allow to switch between images by pressing Alt+&#39;image position&#39; (Alt+0, Alt+1, etc)
    self._context_menu.show()
    self._context_menu.popup( self.mapToGlobal(pos) )</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.show_timing"><code class="name flex">
<span>def <span class="ident">show_timing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_timing(self):
    return self.check_verbosity(self.verbosity_TIMING) or self.check_verbosity(self.verbosity_TIMING_DETAILED)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.show_timing_detailed"><code class="name flex">
<span>def <span class="ident">show_timing_detailed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_timing_detailed(self):
    return self.check_verbosity(self.verbosity_TIMING_DETAILED)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.show_trace"><code class="name flex">
<span>def <span class="ident">show_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_trace(self):
    return self.check_verbosity(self.verbosity_TRACE)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.toggle_display_profiles"><code class="name flex">
<span>def <span class="ident">toggle_display_profiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_display_profiles(self):
    self.figures_widget.setVisible(self.display_profiles.isChecked())
    self.update_image()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.toggle_fullscreen"><code class="name flex">
<span>def <span class="ident">toggle_fullscreen</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_fullscreen(self, event):
    print(f&#34;toggle_fullscreen&#34;)
    if not issubclass(self.__class__,QtWidgets.QWidget):
        print(f&#34;Cannot use toggle_fullscreen on a class that is not a QWidget&#34;)
        return
    # Should be inside a layout
    if self.before_max_parent is None:
        print(f&#34;self.parent() is not None {self.parent() is not None}&#34;)
        print(f&#34;self.parent().layout() {self.parent().layout()} &#34;)
        if self.parent() is not None and (playout := self.parent().layout()) is not None:
            if self.find_in_layout(playout):
                self.before_max_parent = self.parent()
                self.replacing_widget = QtWidgets.QWidget(self.before_max_parent)
                self.parent().layout().replaceWidget(self, self.replacing_widget)
                # We need to go up from the parent widget to the main window to get its geometry
                # so that the fullscreen is display on the same monitor
                toplevel_parent : Optional[QtWidgets.QWidget] = self.parentWidget()
                while toplevel_parent.parentWidget(): toplevel_parent = toplevel_parent.parentWidget()
                self.setParent(None)
                if toplevel_parent: self.setGeometry(toplevel_parent.geometry())
                self.showFullScreen()
                event.accept()
                return
    if self.before_max_parent is not None:
        self.setParent(self.before_max_parent)
        self.parent().layout().replaceWidget(self.replacing_widget, self)
        self.replacing_widget = self.before_max_parent = None
        # self.resize(self.before_max_size)
        self.show()
        self.parent().update()
        self.setFocus()
        event.accept()
        return</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_image"><code class="name flex">
<span>def <span class="ident">update_image</span></span>(<span>self, image_name=None, reload=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the variable self.output_label_current_image
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image(self, image_name=None, reload=False):
    &#34;&#34;&#34;
    Uses the variable self.output_label_current_image
    :return:
    &#34;&#34;&#34;
    self.print_log(&#39;update_image {} current: {}&#39;.format(image_name, self.output_label_current_image))
    update_image_start = get_time()

    # Define the current selected image
    if image_name is not None:
        self.output_label_current_image = image_name
    if self.output_label_current_image == &#34;&#34;:
        return

    if self.image_dict[self.output_label_current_image] is None:
        print(&#34; No image filename for current image&#34;)
        return

    self.update_label_fonts()

    # find first active window
    first_active_window = 0
    for n in range(self.nb_viewers_used):
        self.image_viewers[n].display_timing = self.show_timing()&gt;0
        if self.image_viewers[n].is_active():
            first_active_window = n
            break

    # Read images in parallel to improve preformances
    # list all required image filenames
    # set all viewers image names (labels)
    image_filenames = [self.image_dict[self.output_label_current_image]]
    # define image associated to each used viewer and add it to the list of images to get
    for n in range(self.nb_viewers_used):
        viewer : ImageViewer = self.image_viewers[n]
        # Set active only the first active window
        viewer.set_active(n == first_active_window)
        if viewer.get_image() is None:
            if n &lt; len(self.image_list):
                viewer.image_name = self.image_list[n]
                image_filenames.append(self.image_dict[self.image_list[n]])
            else:
                viewer.image_name = self.output_label_current_image
        else:
            # image_name should belong to image_dict
            if viewer.image_name in self.image_dict:
                image_filenames.append(self.image_dict[viewer.image_name])
            else:
                viewer.image_name = self.output_label_current_image

    # remove duplicates
    image_filenames = list(set(image_filenames))
    # print(f&#34;image filenames {image_filenames}&#34;)
    self.cache_read_images(image_filenames, reload=reload)

    try:
        current_image = self.get_output_image(self.output_label_current_image)
        if current_image is None:
            return
    except Exception as e:
        print(&#34;Error: failed to get image {}: {}&#34;.format(self.output_label_current_image, e))
        return

    # print(f&#34;cur {self.output_label_current_image}&#34;)
    current_filename = self.output_image_label[self.output_label_current_image]

    if self.show_timing_detailed():
        time_spent = get_time() - update_image_start

    self.setMessage(&#34;Image: {0}&#34;.format(current_filename))

    current_viewer = self.image_viewers[first_active_window]
    if self.save_image_clipboard:
        print(&#34;set save image to clipboard&#34;)
        current_viewer.set_clipboard(self.clip, True)
    current_viewer.set_active(True)
    current_viewer.image_name = self.output_label_current_image
    current_viewer.set_image(current_image)
    if self.save_image_clipboard:
        print(&#34;end save image to clipboard&#34;)
        current_viewer.set_clipboard(None, False)

    # print(f&#34;ref {self.output_label_reference_image}&#34;)
    if self.output_label_reference_image==self.output_label_current_image:
        reference_image = current_image
    else:
        reference_image = self.get_output_image(self.output_label_reference_image)

    if self.nb_viewers_used &gt;= 2:
        prev_n = first_active_window
        for n in range(1, self.nb_viewers_used):
            n1 = (first_active_window + n) % self.nb_viewers_used
            viewer = self.image_viewers[n1]
            # viewer image has already been defined
            # try to update corresponding images in row
            try:
                viewer_image = self.get_output_image(viewer.image_name)
            except Exception as e:
                print(&#34;Error: failed to get image {}: {}&#34;.format(viewer.image_name, e))
                viewer.set_image(current_image)
            else:
                viewer.set_image(viewer_image)

            # set reference image
            viewer.set_image_ref(reference_image)

            self.image_viewers[prev_n].set_synchronize(viewer)
            prev_n = n1
        # Create a synchronization loop
        if prev_n != first_active_window:
            self.image_viewers[prev_n].set_synchronize(self.image_viewers[first_active_window])

    # Be sure to show the required viewers
    for n in range(self.nb_viewers_used):
        viewer = self.image_viewers[n]
        # print(f&#34;show viewer {n}&#34;)
        # Note: calling show in any case seems to avoid double calls to paint event that update() triggers
        # viewer.show()
        if viewer.isHidden():
            # print(f&#34;show viewer {n}&#34;)
            viewer.show()
        else:
            # print(f&#34;update viewer {n}&#34;)
            viewer.update()


    # self.image_scroll_area.adjustSize()
    # if self.show_timing():
    print(f&#34; Update image took {(get_time() - update_image_start)*1000:0.0f} ms&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_image_buttons"><code class="name flex">
<span>def <span class="ident">update_image_buttons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image_buttons(self):
    # choose image to display
    self.clear_buttons()
    self.image_list = list(self.image_dict.keys())
    self.print_log(&#34;MultiView.update_image_buttons() {}&#34;.format(self.image_list))
    self.label = dict()
    for image_name in self.image_list:
        # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
        if image_name != &#39;none&#39;:
            self.label[image_name] = MVLabel(image_name, self)
            self.label[image_name].setFrameShape(QtWidgets.QFrame.Panel)
            self.label[image_name].setFrameShadow(QtWidgets.QFrame.Sunken)
            # self.label[image_name].setLineWidth(3)
            self.label[image_name].setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
            # self.label[image_name].setFixedHeight(40)
            self.label[image_name].mousePressEvent = self.make_mouse_press(image_name)
            self.label[image_name].mouseReleaseEvent = self.mouse_release
            self.label[image_name].mouseDoubleClickEvent = self.make_mouse_double_click(image_name)
    self.create_buttons()

    # the crop area can be changed using the mouse wheel
    self.output_label_crop = (0., 0., 1., 1.)

    if len(self.image_list)&gt;0:
        self.output_label_current_image = self.image_list[0]
        self.set_reference_label(self.image_list[0], update_viewers=True)
    else:
        self.output_label_current_image = &#39;&#39;
        self.output_label_reference_image = &#39;&#39;</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_image_intensity_event"><code class="name flex">
<span>def <span class="ident">update_image_intensity_event</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image_intensity_event(self):
    self.update_image_parameters()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_image_parameters"><code class="name flex">
<span>def <span class="ident">update_image_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the variable self.output_label_current_image
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image_parameters(self):
    &#39;&#39;&#39;
    Uses the variable self.output_label_current_image
    :return:
    &#39;&#39;&#39;
    self.print_log(&#39;update_image_parameters&#39;)
    update_start = get_time()

    for n in range(self.nb_viewers_used):
        self.image_viewers[n].filter_params.copy_from(self.filter_params)
        self.image_viewers[n].update()

    if self.show_timing():
        time_spent = get_time() - update_start
        self.print_log(&#34; Update image took {0:0.3f} sec.&#34;.format(time_spent))</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_label_fonts"><code class="name flex">
<span>def <span class="ident">update_label_fonts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_label_fonts(self):
    # Update selected image label, we could do it later too
    for im_name in self.image_list:
        # possibility to disable an image using the string &#39;none&#39;, especially useful for input image
        if im_name != &#39;none&#39;:
            is_bold      = im_name == self.output_label_current_image
            is_underline = im_name == self.output_label_reference_image
            is_bold |= is_underline
            self.bold_font.setBold(is_bold)
            self.bold_font.setUnderline(is_underline)
            self.bold_font.setPointSize(8)
            self.label[im_name].setFont(self.bold_font)
            self.label[im_name].setWordWrap(True)
        # self.label[im_name].setMaximumWidth(160)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_layout"><code class="name flex">
<span>def <span class="ident">update_layout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_layout(self):
    self.print_log(&#34;update_layout&#34;)
    vertical_layout = QtWidgets.QVBoxLayout()
    self.layout_buttons(vertical_layout)

    # First line of parameter control
    parameters_layout = QtWidgets.QHBoxLayout()
    self.layout_parameters(parameters_layout)
    vertical_layout.addLayout(parameters_layout, 1)

    # Second line of parameter control
    parameters2_layout = QtWidgets.QHBoxLayout()
    self.layout_parameters_2(parameters2_layout)
    vertical_layout.addLayout(parameters2_layout, 1)

    self.viewer_grid_layout = QtWidgets.QGridLayout()
    self.viewer_grid_layout.setHorizontalSpacing(1)
    self.viewer_grid_layout.setVerticalSpacing(1)
    self.set_number_of_viewers(1)
    vertical_layout.addLayout(self.viewer_grid_layout, 1)

    self.figures_widget = QtWidgets.QWidget()
    self.figures_layout = QtWidgets.QHBoxLayout()
    self.figures_layout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
    # for the moment ignore this
    # self.figures_layout.addWidget(self.value_in_range_canvas)
    # self.figures_widget.setLayout(self.figures_layout)

    vertical_layout.addWidget(self.figures_widget)
    self.toggle_display_profiles()
    self.setLayout(vertical_layout)
    print(&#34;update_layout done&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_reference"><code class="name flex">
<span>def <span class="ident">update_reference</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_reference(self) -&gt; None:
    reference_image = self.get_output_image(self.output_label_reference_image)
    for n in range(self.nb_viewers_used):
        viewer = self.image_viewers[n]
        # set reference image
        viewer.set_image_ref(reference_image)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.MultiView.update_viewer_mode"><code class="name flex">
<span>def <span class="ident">update_viewer_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_viewer_mode(self):
    viewer_mode = self.viewer_mode_selection.get_selection_value()
    self.image_viewer_class = self.image_viewer_classes[viewer_mode]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qimview.image_viewers.QTImageViewer"><code class="flex name class">
<span>class <span class="ident">QTImageViewer</span></span>
<span>(</span><span>parent=None, event_recorder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QWidget(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p><strong>init</strong>(self, parent: Optional[PySide6.QtWidgets.QWidget] = None, f: PySide6.QtCore.Qt.WindowType = Default(Qt.WindowFlags)) -&gt; None</p>
<p>Initialize self.
See help(type(self)) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QTImageViewer(BaseWidget, ImageViewer ):

    def __init__(self, parent=None, event_recorder=None):
        super().__init__(parent)
        self.event_recorder = event_recorder
        self.setMouseTracking(True)
        self.anti_aliasing = True
        size_policy = QtWidgets.QSizePolicy()
        size_policy.setHorizontalPolicy(QtWidgets.QSizePolicy.Ignored)
        size_policy.setVerticalPolicy(QtWidgets.QSizePolicy.Ignored)
        self.setSizePolicy(size_policy)
        # self.setAlignment(QtCore.Qt.AlignCenter )
        self.output_crop = np.array([0., 0., 1., 1.], dtype=np.float32)
        self.zoom_center = np.array([0.5, 0.5, 0.5, 0.5])


        if &#39;ClickFocus&#39; in QtCore.Qt.FocusPolicy.__dict__:
            self.setFocusPolicy(QtCore.Qt.FocusPolicy.ClickFocus)
        else:
            self.setFocusPolicy(QtCore.Qt.ClickFocus)

        self.paint_cache      = None
        self.paint_diff_cache = None
        self.diff_image       = None

        # self.display_timing = False
        if BaseWidget is QOpenGLWidget:
            self.setAutoFillBackground(True)

        # TODO: how can I set the background color to black without impacting display speed?
        # p = self.palette()
        # p.setColor(self.backgroundRole(), QtCore.Qt.black) 
        # self.setPalette(p)
        # self.setAutoFillBackground(True)

        self.verbose = False
        # self.trace_calls = True

    #def __del__(self):
    #    pass

    def set_image(self, image):
        super().set_image(image)

    def apply_zoom(self, crop):
        (height, width) = self._image.data.shape[:2]
        # print(f&#34;height, width = {height, width}&#34;)
        # Apply zoom
        coeff = 1.0/self.new_scale(self.mouse_zy, height)
        # zoom from the center of the image
        center = self.zoom_center
        new_crop = center + (crop - center) * coeff

        # print(&#34;new crop zoom 1 {}&#34;.format(new_crop))

        # allow crop increase based on the available space
        label_width = self.width()
        # print(f&#34;label_width {label_width}&#34;)
        label_height = self.height()

        new_width = width * coeff
        new_height = height * coeff

        ratio_width = float(label_width) / new_width
        ratio_height = float(label_height) / new_height

        # print(f&#34; ratio_width {ratio_width} ratio_height {ratio_height}&#34;)
        ratio = min(ratio_width, ratio_height)

        if ratio_width&lt;ratio_height:
            # margin to increase height
            margin_pixels = label_height/ratio - new_height
            margin_height = margin_pixels/height
            new_crop[1] -= margin_height/2
            new_crop[3] += margin_height/2
        else:
            # margin to increase width
            margin_pixels = label_width/ratio - new_width
            margin_width = margin_pixels/width
            new_crop[0] -= margin_width/2
            new_crop[2] += margin_width/2
        # print(&#34;new crop zoom 2 {}&#34;.format(new_crop))

        return new_crop

    def apply_translation(self, crop):
        &#34;&#34;&#34;
        :param crop:
        :return: the new crop
        &#34;&#34;&#34;
        # Apply translation
        diff_x, diff_y = self.new_translation()
        diff_y = - diff_y
        # print(&#34; new translation {} {}&#34;.format(diff_x, diff_y))
        # apply the maximal allowed translation
        tr_x = float(diff_x) / self.width()
        tr_y = float(diff_y) / self.height()
        tr_x = clip_value(tr_x, crop[2]-1, crop[0])
        tr_y = clip_value(tr_y, crop[3]-1, crop[1])
        # normalized position relative to the full image
        crop[0] -= tr_x
        crop[1] -= tr_y
        crop[2] -= tr_x
        crop[3] -= tr_y

    def check_translation(self):
        &#34;&#34;&#34;
        This method computes the translation really applied based on the current requested translation
        :return:
        &#34;&#34;&#34;
        # Apply zoom
        crop = self.apply_zoom(self.output_crop)

        # Compute the translation that is really applied after applying the constraints
        diff_x, diff_y = self.new_translation()
        diff_y = - diff_y
        # print(&#34; new translation {} {}&#34;.format(diff_x, diff_y))
        # apply the maximal allowed translation
        w, h = self.width(), self.height()
        diff_x = clip_value(diff_x, w*(crop[2]-1), w*(crop[0]))
        diff_y = - clip_value(diff_y, h*(crop[3]-1), h*(crop[1]))
        # normalized position relative to the full image
        return diff_x, diff_y

    def update_crop(self):
        # Apply zoom
        new_crop = self.apply_zoom(self.output_crop)
        # print(f&#34;update_crop {self.output_crop} --&gt; {new_crop}&#34;)
        # Apply translation
        self.apply_translation(new_crop)
        new_crop = np.clip(new_crop, 0, 1)
        # print(&#34;move new crop {}&#34;.format(new_crop))
        # print(f&#34;output_crop {self.output_crop} new crop {new_crop}&#34;)
        return new_crop

    def update_crop_new(self):
        # 1. transform crop to display coordinates
        
        # Apply zoom
        new_crop = self.apply_zoom(self.output_crop)
        # print(f&#34;update_crop {self.output_crop} --&gt; {new_crop}&#34;)
        # Apply translation
        self.apply_translation(new_crop)
        new_crop = np.clip(new_crop, 0, 1)
        # print(&#34;move new crop {}&#34;.format(new_crop))
        # print(f&#34;output_crop {self.output_crop} new crop {new_crop}&#34;)
        return new_crop

    def apply_filters(self, current_image):
        self.print_log(f&#34;current_image.data.shape {current_image.data.shape}&#34;)
        # return current_image

        self.start_timing(title=&#39;apply_filters()&#39;)

        # Output RGB from input
        ch = self._image.channels
        if has_cppbind:
            channels = current_image.channels
            black_level = self.filter_params.black_level.float
            white_level = self.filter_params.white_level.float
            g_r_coeff = self.filter_params.g_r.float
            g_b_coeff = self.filter_params.g_b.float
            saturation = self.filter_params.saturation.float
            max_value = ((1&lt;&lt;current_image.precision)-1)
            max_type = 1  # not used
            gamma = self.filter_params.gamma.float  # not used

            rgb_image = np.empty((current_image.data.shape[0], current_image.data.shape[1], 3), dtype=np.uint8)
            time1 = get_time()
            ok = False
            if ch in ImageFormat.CH_RAWFORMATS() or ch in ImageFormat.CH_RGBFORMATS():
                cases = {
                    &#39;uint8&#39;:  { &#39;func&#39;: qimview_cpp.apply_filters_u8_u8  , &#39;name&#39;: &#39;apply_filters_u8_u8&#39;},
                    &#39;uint16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_u16_u8, &#39;name&#39;: &#39;apply_filters_u16_u8&#39;},
                    &#39;uint32&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_u32_u8, &#39;name&#39;: &#39;apply_filters_u32_u8&#39;},
                    &#39;int16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_s16_u8, &#39;name&#39;: &#39;apply_filters_s16_u8&#39;},
                    &#39;int32&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_s32_u8, &#39;name&#39;: &#39;apply_filters_s32_u8&#39;}
                }
                if current_image.data.dtype.name in cases:
                    func = cases[current_image.data.dtype.name][&#39;func&#39;]
                    name = cases[current_image.data.dtype.name][&#39;name&#39;]
                    self.print_log(f&#34;qimview_cpp.{name}(current_image, rgb_image, channels, &#34;
                          f&#34;black_level={black_level}, white_level={white_level}, &#34;
                          f&#34;g_r_coeff={g_r_coeff}, g_b_coeff={g_b_coeff}, &#34;
                          f&#34;max_value={max_value}, max_type={max_type}, gamma={gamma})&#34;)
                    ok = func(current_image.data, rgb_image, channels, black_level, white_level, g_r_coeff,
                                g_b_coeff, max_value, max_type, gamma, saturation)
                    self.add_time(f&#39;{name}()&#39;,time1, force=True, title=&#39;apply_filters()&#39;)
                else:
                    print(f&#34;apply_filters() not available for {current_image.data.dtype} data type !&#34;)
            else:
                cases = {
                    &#39;uint8&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_u8_u8, &#39;name&#39;: &#39;apply_filters_scalar_u8_u8&#39;},
                    &#39;uint16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_u16_u8, &#39;name&#39;: &#39;apply_filters_scalar_u16_u8&#39;},
                    &#39;int16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_s16_u8, &#39;name&#39;: &#39;apply_filters_scalar_s16_u8&#39;},
                    &#39;uint32&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_u32_u8, &#39;name&#39;: &#39;apply_filters_scalar_u32_u8&#39;},
                    &#39;float64&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_f64_u8, &#39;name&#39;: &#39;apply_filters_scalar_f64_u8&#39;},
                }
                if current_image.data.dtype.name.startswith(&#39;float&#39;):
                    max_value = 1.0
                if current_image.data.dtype.name in cases:
                    func = cases[current_image.data.dtype.name][&#39;func&#39;]
                    name = cases[current_image.data.dtype.name][&#39;name&#39;]
                    self.print_log(f&#34;qimview_cpp.{name}(current_image, rgb_image, &#34;
                          f&#34;black_level={black_level}, white_level={white_level}, &#34;
                          f&#34;max_value={max_value}, max_type={max_type}, gamma={gamma})&#34;)
                    ok = func(current_image.data, rgb_image, black_level, white_level, max_value, max_type, gamma)
                    self.add_time(f&#39;{name}()&#39;, time1, force=True, title=&#39;apply_filters()&#39;)
                else:
                    print(f&#34;apply_filters_scalar() not available for {current_image.data.dtype} data type !&#34;)
            if not ok:
                self.print_log(&#34;Failed running wrap_num.apply_filters_u16_u8 ...&#34;, force=True)
        else:
            # self.print_log(&#34;current channels {}&#34;.format(ch))
            if ch in ImageFormat.CH_RAWFORMATS():
                channel_pos = channel_position[current_image.channels]
                self.print_log(&#34;Converting to RGB&#34;)
                # convert Bayer to RGB
                rgb_image = np.empty((current_image.data.shape[0], current_image.data.shape[1], 3), 
                                        dtype=current_image.data.dtype)
                rgb_image[:, :, 0] = current_image.data[:, :, channel_pos[&#39;r&#39;]]
                rgb_image[:, :, 1] = (current_image.data[:, :, channel_pos[&#39;gr&#39;]]+current_image.data[:, :, channel_pos[&#39;gb&#39;]])/2
                rgb_image[:, :, 2] = current_image.data[:, :, channel_pos[&#39;b&#39;]]
            else:
                if ch == ImageFormat.CH_Y:
                    # Transform to RGB is it a good idea?
                    rgb_image = np.empty((current_image.data.shape[0], current_image.data.shape[1], 3), 
                                            dtype=current_image.data.dtype)
                    rgb_image[:, :, 0] = current_image.data
                    rgb_image[:, :, 1] = current_image.data
                    rgb_image[:, :, 2] = current_image.data
                else:
                    rgb_image = current_image.data

            # Use cv2.convertScaleAbs(I,a,b) function for fast processing
            # res = sat(|I*a+b|)
            # if current_image is not in 8 bits, we need to rescale
            min_val = self.filter_params.black_level.float
            max_val = self.filter_params.white_level.float

            if min_val != 0 or max_val != 1 or current_image.precision!=8:
                min_val = self.filter_params.black_level.float
                max_val = self.filter_params.white_level.float
                # adjust levels to precision
                precision = current_image.precision
                min_val = min_val*((1 &lt;&lt; precision)-1)
                max_val = max_val*((1 &lt;&lt; precision)-1)
                if rgb_image.dtype == np.uint32:
                    # Formula a bit complicated, we need to be careful with unsigned processing
                    rgb_image =np.clip(((np.clip(rgb_image, min_val, None) - min_val)*(255/(max_val-min_val)))+0.5,
                                       None, 255).astype(np.uint8)
                else:
                    # to rescale: add min_val and multiply by (max_val-min_val)/255
                    if min_val != 0:
                        rgb_image = cv2.add(rgb_image, (-min_val, -min_val, -min_val, 0))
                    rgb_image = cv2.convertScaleAbs(rgb_image, alpha=255. / float(max_val - min_val), beta=0)

            # # if gamma changed
            # if self.filter_params.gamma.value != self.filter_params.gamma.default_value and work_image.dtype == np.uint8:
            #     gamma_coeff = self.filter_params.gamma.float
            #     # self.gamma_label.setText(&#34;Gamma  {}&#34;.format(gamma_coeff))
            #     invGamma = 1.0 / gamma_coeff
            #     table = np.array([((i / 255.0) ** invGamma) * 255 for i in np.arange(0, 256)]).astype(&#34;uint8&#34;)
            #     work_image = cv2.LUT(work_image, table)

        self.print_timing(title=&#39;apply_filters()&#39;)
        return rgb_image

    def viewer_update(self):
        if BaseWidget is QOpenGLWidget:
            self.paint_image()
            self.repaint()
        else:
            self.update()

    def draw_overlay_separation(self, cropped_image_shape, rect, painter):
        (height, width) = cropped_image_shape[:2]
        im_x = int((self.mouse_x - rect.x())/rect.width()*width)
        im_x = max(0, min(width - 1, im_x))
        # im_y = int((self.mouse_y - rect.y())/rect.height()*height)
        # Set position at the beginning of the pixel
        pos_from_im_x = int(im_x*rect.width()/width + rect.x())
        # pos_from_im_y = int((im_y+0.5)*rect.height()/height+ rect.y())
        pen_width = 2
        color = QtGui.QColor(255, 255, 0 , 128)
        pen = QtGui.QPen()
        pen.setColor(color)
        pen.setWidth(pen_width)
        painter.setPen(pen)
        painter.drawLine(pos_from_im_x, rect.y(), pos_from_im_x, rect.y() + rect.height())

    def draw_cursor(self, cropped_image_shape, crop_xmin, crop_ymin, rect, painter, full=False) -&gt; Optional[Tuple[int, int]]:
        &#34;&#34;&#34;
        :param cropped_image_shape: dimensions of current crop
        :param crop_xmin: left pixel of current crop
        :param crop_ymin: top pixel of current crop
        :param rect: displayed image area
        :param painter:
        :return:
            tuple: (posx, posy) image pixel position of the cursor, if None cursor is out of image
        &#34;&#34;&#34;
        # Draw cursor
        if self.display_timing: self.start_timing()
        # get image position
        (height, width) = cropped_image_shape[:2]
        im_x = int((self.mouse_x -rect.x())/rect.width()*width)
        im_y = int((self.mouse_y -rect.y())/rect.height()*height)

        pos_from_im_x = int((im_x+0.5)*rect.width()/width +rect.x())
        pos_from_im_y = int((im_y+0.5)*rect.height()/height+rect.y())

        # ratio = self.screen().devicePixelRatio()
        # print(&#34;ratio = {}&#34;.format(ratio))
        pos_x = pos_from_im_x  # *ratio
        pos_y = pos_from_im_y  # *ratio
        length_percent = 0.04
        # use percentage of the displayed image dimensions
        length = int(max(self.width(),self.height())*length_percent)
        pen_width = 2 if full else 3
        color = QtGui.QColor(0, 255, 255, 200)
        pen = QtGui.QPen()
        pen.setColor(color)
        pen.setWidth(pen_width)
        painter.setPen(pen)
        if not full:
            painter.drawLine(pos_x-length, pos_y, pos_x+length, pos_y)
            painter.drawLine(pos_x, pos_y-length, pos_x, pos_y+length)
        else:
            painter.drawLine(rect.x(), pos_y, rect.x()+rect.width(), pos_y)
            painter.drawLine(pos_x, rect.y(), pos_x, rect.y()+rect.height())

        # Update text
        if im_x&gt;=0 and im_x&lt;cropped_image_shape[1] and im_y&gt;=0 and im_y&lt;cropped_image_shape[0]:
            # values = cropped_image[im_y, im_x]
            im_x += crop_xmin
            im_y += crop_ymin
            im_pos = (im_x, im_y)
        else:
            im_pos = None
        if self.display_timing: self.print_timing()
        return im_pos

    def get_difference_image(self, verbose=True):

        factor = self.filter_params.imdiff_factor.float
        if self.paint_diff_cache is not None:
            use_cache = self.paint_diff_cache[&#39;imid&#39;] == self.image_id and \
                        self.paint_diff_cache[&#39;imrefid&#39;] == self.image_ref_id and \
                        self.paint_diff_cache[&#39;factor&#39;] == factor
        else:
            use_cache = False

        if not use_cache:
            im1 = self._image.data
            im2 = self._image_ref.data
            # TODO: get factor from parameters ...
            # factor = int(self.diff_color_slider.value())
            print(f&#39;factor = {factor}&#39;)
            print(f&#39; im1.dtype {im1.dtype} im2.dtype {im2.dtype}&#39;)
            # Fast OpenCV code
            start = get_time()
            # positive diffs in unsigned 8 bits, OpenCV puts negative values to 0
            try:
                if im1.dtype.name == &#39;uint8&#39; and im2.dtype.name == &#39;uint8&#39;:
                    diff_plus = cv2.subtract(im1, im2)
                    diff_minus = cv2.subtract(im2, im1)
                    res = cv2.addWeighted(diff_plus, factor, diff_minus, -factor, 127)
                    if verbose:
                        print(f&#34; qtImageViewer.difference_image()  took {int((get_time() - start)*1000)} ms&#34;)
                        vmin = np.min(res)
                        vmax = np.max(res)
                        print(f&#34;min-max diff = {vmin} - {vmax}&#34;)
                        histo,_ = np.histogram(res, bins=int(vmax-vmin+0.5), range=(vmin, vmax))
                        sum = 0
                        for v in range(vmin,vmax):
                            if v!=127:
                                nb = histo[v-vmin]
                                if nb &gt;0:
                                    print(f&#34;{v-127}:{nb} &#34;,end=&#39;&#39;)
                                    sum += nb
                        print(&#39;&#39;)
                        print(f&#39;nb pixel diff  {sum}&#39;)
                    res = ViewerImage(res,  precision=self._image.precision, 
                                            downscale=self._image.downscale,
                                            channels=self._image.channels)
                    self.paint_diff_cache = {  &#39;imid&#39;: self.image_id, &#39;imrefid&#39;: self.image_ref_id, 
                        &#39;factor&#39;: self.filter_params.imdiff_factor.float
                    }
                    self.diff_image = res
                else:
                    d = (im1.astype(np.float32)-im2.astype(np.float32))*factor
                    d[d&lt;-127] = -127
                    d[d&gt;128] = 128
                    d = (d+127).astype(np.uint8)*255
                    res = ViewerImage(d,  precision=8, 
                                            downscale=self._image.downscale,
                                            channels=self._image.channels)
                    self.paint_diff_cache = {  &#39;imid&#39;: self.image_id, &#39;imrefid&#39;: self.image_ref_id, 
                        &#39;factor&#39;: self.filter_params.imdiff_factor.float
                    }
                    self.diff_image = res
            except Exception as e:
                print(f&#34;Error {e}&#34;)
                res = (im1!=im2).astype(np.uint8)*255
                res = ViewerImage(res,  precision=8, 
                                        downscale=self._image.downscale,
                                        channels=ImageFormat.CH_Y)
                self.diff_image = res

        return self.diff_image

    def paint_image(self):
        # print(f&#34;paint_image display_timing {self.display_timing}&#34;)
        if self.trace_calls: t = trace_method(self.tab)
        self.start_timing()
        time0 = time1 = get_time()

        label_width = self.size().width()
        label_height = self.size().height()

        show_diff = self.show_image_differences and self._image is not self._image_ref and \
                    self._image_ref is not None and self._image.data.shape == self._image_ref.data.shape

        c = self.update_crop()
        # check paint_cache
        if self.paint_cache is not None:
            use_cache = self.paint_cache[&#39;imid&#39;] == self.image_id and \
                        np.array_equal(self.paint_cache[&#39;crop&#39;],c) and \
                        self.paint_cache[&#39;labelw&#39;] == label_width and \
                        self.paint_cache[&#39;labelh&#39;] == label_height and \
                        self.paint_cache[&#39;filterp&#39;].is_equal(self.filter_params) and \
                        (self.paint_cache[&#39;showhist&#39;] == self.show_histogram or not self.show_histogram) and \
                        self.paint_cache[&#39;show_diff&#39;] == show_diff and \
                        self.paint_cache[&#39;antialiasing&#39;] == self.antialiasing and \
                        not self.show_overlay
        else:
            use_cache = False

        # if show_diff, compute the image difference (put it in cache??)
        if show_diff:
            # Cache does not work well with differences
            use_cache = False
            # don&#39;t save the difference
            current_image = self.get_difference_image()
        else:
            current_image = self._image

        precision  = current_image.precision
        downscale  = current_image.downscale
        channels   = current_image.channels

        # TODO: get data based on the display ratio?
        image_data = current_image.data

        # could_use_cache = use_cache
        # if could_use_cache:
        #     print(&#34; Could use cache here ... !!!&#34;)
        # use_cache = False

        do_crop = (c[2] - c[0] != 1) or (c[3] - c[1] != 1)
        h, w  = image_data.shape[:2]
        if do_crop:
            crop_xmin = int(np.round(c[0] * w))
            crop_xmax = int(np.round(c[2] * w))
            crop_ymin = int(np.round(c[1] * h))
            crop_ymax = int(np.round(c[3] * h))
            image_data = image_data[crop_ymin:crop_ymax, crop_xmin:crop_xmax]
        else:
            crop_xmin = crop_ymin = 0
            crop_xmax = w
            crop_ymax = h

        cropped_image_shape = image_data.shape
        self.add_time(&#39;crop&#39;, time1)

        # time1 = get_time()
        image_height, image_width  = image_data.shape[:2]
        ratio_width = float(label_width) / image_width
        ratio_height = float(label_height) / image_height
        ratio = min(ratio_width, ratio_height)
        display_width = int(round(image_width * ratio))
        display_height = int(round(image_height * ratio))

        if self.show_overlay and self._image_ref is not self._image and self._image_ref and \
            self._image.data.shape == self._image_ref.data.shape:
            # to create the overlay rapidly, we will mix the two images based on the current cursor position
            # 1. convert cursor position to image position
            (height, width) = cropped_image_shape[:2]
            # compute rect
            rect = QtCore.QRect(0, 0, display_width, display_height)
            devRect = QtCore.QRect(0, 0, self.evt_width, self.evt_height)
            rect.moveCenter(devRect.center())
            im_x = int((self.mouse_x - rect.x()) / rect.width() * width)
            im_x = max(0,min(width-1, im_x))
            # im_y = int((self.mouse_y - rect.y()) / rect.height() * height)
            # We need to have a copy here .. slow, better option???
            image_data = np.copy(image_data)
            image_data[:, :im_x] = self._image_ref.data[crop_ymin:crop_ymax, crop_xmin:(crop_xmin+im_x)]

        resize_applied = False
        if not use_cache:
            anti_aliasing = ratio &lt; 1
            #self.print_log(&#34;ratio is {:0.2f}&#34;.format(ratio))
            use_opencv_resize = anti_aliasing
            # enable this as optional?
            # opencv_downscale_interpolation = opencv_fast_interpolation
            opencv_fast_interpolation = cv2.INTER_NEAREST
            if self.antialiasing:
                opencv_downscale_interpolation = cv2.INTER_AREA
            else:
                opencv_downscale_interpolation = cv2.INTER_NEAREST
            # opencv_upscale_interpolation   = cv2.INTER_LINEAR
            opencv_upscale_interpolation   = opencv_fast_interpolation
            # self.print_time(&#39;several settings&#39;, time1, start_time)

            # self.print_log(&#34;use_opencv_resize {} channels {}&#34;.format(use_opencv_resize, current_image.channels))
            # if ratio&lt;1 we want anti aliasing and we want to resize as soon as possible to reduce computation time
            if use_opencv_resize and not resize_applied and channels == ImageFormat.CH_RGB:

                prev_shape = image_data.shape
                initial_type = image_data.dtype
                if image_data.dtype != np.uint8:
                    print(f&#34;image_data type {type(image_data)} {image_data.dtype}&#34;)
                    image_data = image_data.astype(np.float32)

                # if ratio is &gt;2, start with integer downsize which is much faster
                # we could add this condition opencv_downscale_interpolation==cv2.INTER_AREA
                if ratio&lt;=0.5:
                    if image_data.shape[0]%2!=0 or image_data.shape[1]%2 !=0:
                        # clip image to multiple of 2 dimension
                        image_data = image_data[:2*(image_data.shape[0]//2),:2*(image_data.shape[1]//2)]
                    start_0 = get_time()
                    resized_image = cv2.resize(image_data, (image_width&gt;&gt;1, image_height&gt;&gt;1),
                                            interpolation=opencv_downscale_interpolation)
                    if self.display_timing:
                        print(f&#39; === qtImageViewer: ratio {ratio:0.2f} paint_image() OpenCV resize from &#39;
                            f&#39;{current_image.data.shape} to &#39;
                            f&#39;{resized_image.shape} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)
                    image_data = resized_image
                    if ratio&lt;=0.25:
                        if image_data.shape[0]%2!=0 or image_data.shape[1]%2 !=0:
                            # clip image to multiple of 2 dimension
                            image_data = image_data[:2*(image_data.shape[0]//2),:2*(image_data.shape[1]//2)]
                        start_0 = get_time()
                        resized_image = cv2.resize(image_data, (image_width&gt;&gt;2, image_height&gt;&gt;2),
                                                interpolation=opencv_downscale_interpolation)
                        if self.display_timing:
                            print(f&#39; === qtImageViewer: ratio {ratio:0.2f} paint_image() OpenCV resize from &#39;
                                f&#39;{current_image.data.shape} to &#39;
                                f&#39;{resized_image.shape} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)
                        image_data = resized_image

                time1 = get_time()
                start_0 = get_time()
                resized_image = cv2.resize(image_data, (display_width, display_height),
                                        interpolation=opencv_downscale_interpolation)
                if self.display_timing:
                    print(f&#39; === qtImageViewer: paint_image() OpenCV resize from {image_data.shape} to &#39;
                        f&#39;{resized_image.shape} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)

                image_data = resized_image.astype(initial_type)
                resize_applied = True
                self.add_time(&#39;cv2.resize&#39;,time1)

            current_image = ViewerImage(image_data,  precision=precision, downscale=downscale, channels=channels)
            if self.show_stats:
                # Output RGB from input
                ch = self._image.channels
                data_shape = current_image.data.shape
                if len(data_shape)==2:
                    print(f&#34;input average {np.average(current_image.data)}&#34;)
                if len(data_shape)==3:
                    for c in range(data_shape[2]):
                        print(f&#34;input average ch {c} {np.average(current_image.data[:,:,c])}&#34;)
            current_image = self.apply_filters(current_image)

            # Compute the histogram here, with the smallest image!!!
            if self.show_histogram:
                # previous version only python with its modules
                # histograms  = self.compute_histogram    (current_image, show_timings=self.display_timing)
                # new version with bound C++ code and openMP: much faster
                histograms = self.compute_histogram_Cpp(current_image, show_timings=self.display_timing)
            else:
                histograms = None

            # try to resize anyway with opencv since qt resizing seems too slow
            if not resize_applied and BaseWidget is not QOpenGLWidget:
                time1 = get_time()
                start_0 = get_time()
                prev_shape = current_image.shape
                current_image = cv2.resize(current_image, (display_width, display_height),
                                           interpolation=opencv_upscale_interpolation)
                if self.display_timing:
                    print(f&#39; === qtImageViewer: paint_image() OpenCV resize from {prev_shape} to &#39;
                        f&#39;{(display_height, display_width)} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)
                    self.add_time(&#39;cv2.resize&#39;,time1)

            # no need for more resizing
            resize_applied = True

            # Conversion from numpy array to QImage
            # version 1: goes through PIL image
            # version 2: use QImage constructor directly, faster
            # time1 = get_time()

        else:
            resize_applied = True
            current_image = self.paint_cache[&#39;current_image&#39;]
            histograms = self.paint_cache[&#39;histograms&#39;]
            # histograms2 = self.paint_cache[&#39;histograms2&#39;]

        # if could_use_cache:
        #     print(f&#34; ======= current_image equal ? {np.array_equal(self.paint_cache[&#39;current_image&#39;],current_image)}&#34;)

        if not use_cache and not self.show_overlay:
            # cache_time = get_time()
            fp = ImageFilterParameters()
            fp.copy_from(self.filter_params)
            self.paint_cache = {
                &#39;imid&#39;: self.image_id,
                &#39;imrefid&#39;: self.image_ref_id,
                &#39;crop&#39;: c, &#39;labelw&#39;: label_width, &#39;labelh&#39;: label_height,
                &#39;filterp&#39;: fp, &#39;showhist&#39;: self.show_histogram,
                &#39;histograms&#39;: histograms, 
                # &#39;histograms2&#39;: histograms2, 
                &#39;current_image&#39;: current_image,
                &#39;show_diff&#39; : show_diff,
                &#39;antialiasing&#39;: self.antialiasing
                }
            # print(f&#34;create cache data took {int((get_time() - cache_time) * 1000)} ms&#34;)

        if not current_image.flags[&#39;C_CONTIGUOUS&#39;]:
            current_image = np.require(current_image, np.uint8, &#39;C&#39;)
        qimage = QtGui.QImage(current_image.data, current_image.shape[1], current_image.shape[0],
                                    current_image.strides[0], QtGui.QImage.Format_RGB888)
        # self.add_time(&#39;QtGui.QPixmap&#39;,time1)

        assert resize_applied, &#34;Image resized should be applied at this point&#34;
        # if not resize_applied:
        #     printf(&#34;*** We should never get here ***&#34;)
        #     time1 = get_time()
        #     if anti_aliasing:
        #         qimage = qimage.scaled(display_width, display_height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
        #     else:
        #         qimage = qimage.scaled(display_width, display_height, QtCore.Qt.KeepAspectRatio)
        #     self.add_time(&#39;qimage.scaled&#39;, time1)
        #     resize_applied = True

        if self.save_image_clipboard:
            self.print_log(&#34;exporting to clipboard&#34;)
            self.clipboard.setImage(qimage, mode=QtGui.QClipboard.Clipboard)

        painter : QtGui.QPainter = QtGui.QPainter()

        painter.begin(self)
        if BaseWidget is QOpenGLWidget:
            painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # TODO: check that this condition is not needed
        if BaseWidget is QOpenGLWidget:
            rect = QtCore.QRect(0,0, display_width, display_height)
        else:
            rect = QtCore.QRect(qimage.rect())
        devRect = QtCore.QRect(0, 0, self.evt_width, self.evt_height)
        rect.moveCenter(devRect.center())

        time1 = get_time()
        if BaseWidget is QOpenGLWidget:
            painter.drawImage(rect, qimage)
        else:
            painter.drawImage(rect.topLeft(), qimage)
        self.add_time(&#39;painter.drawImage&#39;,time1)

        if self.show_overlay:
            self.draw_overlay_separation(cropped_image_shape, rect, painter)

        # Draw cursor
        im_pos = None
        if self.show_cursor:
            im_pos = self.draw_cursor(cropped_image_shape, 
                                      crop_xmin, 
                                      crop_ymin, 
                                      rect, 
                                      painter, 
                                      full = self.show_intensity_line,
                                      )

        if self.show_intensity_line:
            (height, width) = cropped_image_shape[:2]
            im_y = int((self.mouse_y -rect.y())/rect.height()*height)
            im_y += crop_ymin
            im_shape = self._image.data.shape
            # Horizontal display
            if im_y&gt;=0 and im_y&lt;im_shape[0] and crop_xmin&gt;=0 and crop_xmin+cropped_image_shape[1]&lt;=im_shape[1]:
                line = self._image.data[im_y, crop_xmin:crop_xmin+cropped_image_shape[1]]
                self.display_intensity_line(
                    painter, 
                    rect, 
                    line,
                    channels = self._image.channels,
                    )

        self.display_text(painter, self.display_message(im_pos, ratio*self.devicePixelRatio()))

        # draw histogram
        if self.show_histogram:
            self.display_histogram(histograms, 1,  painter, rect, show_timings=self.display_timing)
            # self.display_histogram(histograms2, 2, painter, rect, show_timings=self.display_timing)

        painter.end()
        self.print_timing()

        if self.display_timing:
            print(f&#34; paint_image took {int((get_time()-time0)*1000)} ms&#34;)

    def show(self):
        if BaseWidget==QOpenGLWidget:
            self.update()
        BaseWidget.show(self)

    def paintEvent(self, event):
        # print(f&#34; qtImageViewer.paintEvent() {self.image_name}&#34;)
        if self.trace_calls:
            t = trace_method(self.tab)
        # try:
        if self._image is not None:
            self.paint_image()
        # except Exception as e:
        #     print(f&#34;Failed paint_image() {e}&#34;)

    def resizeEvent(self, event):
        &#34;&#34;&#34;Called upon window resizing: reinitialize the viewport.
        &#34;&#34;&#34;
        if self.trace_calls:
            t = trace_method(self.tab)
        self.print_log(f&#34;resize {event.size()}  self {self.width()} {self.height()}&#34;)
        self.evt_width = event.size().width()
        self.evt_height = event.size().height()
        BaseWidget.resizeEvent(self, event)
        self.print_log(f&#34;resize {event.size()}  self {self.width()} {self.height()}&#34;)

    def mousePressEvent(self, event):
        self.mouse_press_event(event)

    def mouseMoveEvent(self, event):
        self.mouse_move_event(event)

    def mouseReleaseEvent(self, event):
        self.mouse_release_event(event)

    def mouseDoubleClickEvent(self, event):
        self.mouse_double_click_event(event)

    def wheelEvent(self, event):
        self.mouse_wheel_event(event)

    def event(self, evt):
        if self.event_recorder is not None:
            self.event_recorder.store_event(self, evt)
        return BaseWidget.event(self, evt)

    def keyPressEvent(self, event):
        self.key_press_event(event, wsize=self.size())

    def keyReleaseEvent(self, evt):
        self.print_log(f&#34;evt {evt.type()}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PySide6.QtWidgets.QWidget</li>
<li>PySide6.QtCore.QObject</li>
<li>PySide6.QtGui.QPaintDevice</li>
<li>Shiboken.Object</li>
<li><a title="qimview.image_viewers.image_viewer.ImageViewer" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer">ImageViewer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qimview.image_viewers.QTImageViewer.staticMetaObject"><code class="name">var <span class="ident">staticMetaObject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qimview.image_viewers.QTImageViewer.apply_filters"><code class="name flex">
<span>def <span class="ident">apply_filters</span></span>(<span>self, current_image)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_filters(self, current_image):
    self.print_log(f&#34;current_image.data.shape {current_image.data.shape}&#34;)
    # return current_image

    self.start_timing(title=&#39;apply_filters()&#39;)

    # Output RGB from input
    ch = self._image.channels
    if has_cppbind:
        channels = current_image.channels
        black_level = self.filter_params.black_level.float
        white_level = self.filter_params.white_level.float
        g_r_coeff = self.filter_params.g_r.float
        g_b_coeff = self.filter_params.g_b.float
        saturation = self.filter_params.saturation.float
        max_value = ((1&lt;&lt;current_image.precision)-1)
        max_type = 1  # not used
        gamma = self.filter_params.gamma.float  # not used

        rgb_image = np.empty((current_image.data.shape[0], current_image.data.shape[1], 3), dtype=np.uint8)
        time1 = get_time()
        ok = False
        if ch in ImageFormat.CH_RAWFORMATS() or ch in ImageFormat.CH_RGBFORMATS():
            cases = {
                &#39;uint8&#39;:  { &#39;func&#39;: qimview_cpp.apply_filters_u8_u8  , &#39;name&#39;: &#39;apply_filters_u8_u8&#39;},
                &#39;uint16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_u16_u8, &#39;name&#39;: &#39;apply_filters_u16_u8&#39;},
                &#39;uint32&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_u32_u8, &#39;name&#39;: &#39;apply_filters_u32_u8&#39;},
                &#39;int16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_s16_u8, &#39;name&#39;: &#39;apply_filters_s16_u8&#39;},
                &#39;int32&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_s32_u8, &#39;name&#39;: &#39;apply_filters_s32_u8&#39;}
            }
            if current_image.data.dtype.name in cases:
                func = cases[current_image.data.dtype.name][&#39;func&#39;]
                name = cases[current_image.data.dtype.name][&#39;name&#39;]
                self.print_log(f&#34;qimview_cpp.{name}(current_image, rgb_image, channels, &#34;
                      f&#34;black_level={black_level}, white_level={white_level}, &#34;
                      f&#34;g_r_coeff={g_r_coeff}, g_b_coeff={g_b_coeff}, &#34;
                      f&#34;max_value={max_value}, max_type={max_type}, gamma={gamma})&#34;)
                ok = func(current_image.data, rgb_image, channels, black_level, white_level, g_r_coeff,
                            g_b_coeff, max_value, max_type, gamma, saturation)
                self.add_time(f&#39;{name}()&#39;,time1, force=True, title=&#39;apply_filters()&#39;)
            else:
                print(f&#34;apply_filters() not available for {current_image.data.dtype} data type !&#34;)
        else:
            cases = {
                &#39;uint8&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_u8_u8, &#39;name&#39;: &#39;apply_filters_scalar_u8_u8&#39;},
                &#39;uint16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_u16_u8, &#39;name&#39;: &#39;apply_filters_scalar_u16_u8&#39;},
                &#39;int16&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_s16_u8, &#39;name&#39;: &#39;apply_filters_scalar_s16_u8&#39;},
                &#39;uint32&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_u32_u8, &#39;name&#39;: &#39;apply_filters_scalar_u32_u8&#39;},
                &#39;float64&#39;: { &#39;func&#39;: qimview_cpp.apply_filters_scalar_f64_u8, &#39;name&#39;: &#39;apply_filters_scalar_f64_u8&#39;},
            }
            if current_image.data.dtype.name.startswith(&#39;float&#39;):
                max_value = 1.0
            if current_image.data.dtype.name in cases:
                func = cases[current_image.data.dtype.name][&#39;func&#39;]
                name = cases[current_image.data.dtype.name][&#39;name&#39;]
                self.print_log(f&#34;qimview_cpp.{name}(current_image, rgb_image, &#34;
                      f&#34;black_level={black_level}, white_level={white_level}, &#34;
                      f&#34;max_value={max_value}, max_type={max_type}, gamma={gamma})&#34;)
                ok = func(current_image.data, rgb_image, black_level, white_level, max_value, max_type, gamma)
                self.add_time(f&#39;{name}()&#39;, time1, force=True, title=&#39;apply_filters()&#39;)
            else:
                print(f&#34;apply_filters_scalar() not available for {current_image.data.dtype} data type !&#34;)
        if not ok:
            self.print_log(&#34;Failed running wrap_num.apply_filters_u16_u8 ...&#34;, force=True)
    else:
        # self.print_log(&#34;current channels {}&#34;.format(ch))
        if ch in ImageFormat.CH_RAWFORMATS():
            channel_pos = channel_position[current_image.channels]
            self.print_log(&#34;Converting to RGB&#34;)
            # convert Bayer to RGB
            rgb_image = np.empty((current_image.data.shape[0], current_image.data.shape[1], 3), 
                                    dtype=current_image.data.dtype)
            rgb_image[:, :, 0] = current_image.data[:, :, channel_pos[&#39;r&#39;]]
            rgb_image[:, :, 1] = (current_image.data[:, :, channel_pos[&#39;gr&#39;]]+current_image.data[:, :, channel_pos[&#39;gb&#39;]])/2
            rgb_image[:, :, 2] = current_image.data[:, :, channel_pos[&#39;b&#39;]]
        else:
            if ch == ImageFormat.CH_Y:
                # Transform to RGB is it a good idea?
                rgb_image = np.empty((current_image.data.shape[0], current_image.data.shape[1], 3), 
                                        dtype=current_image.data.dtype)
                rgb_image[:, :, 0] = current_image.data
                rgb_image[:, :, 1] = current_image.data
                rgb_image[:, :, 2] = current_image.data
            else:
                rgb_image = current_image.data

        # Use cv2.convertScaleAbs(I,a,b) function for fast processing
        # res = sat(|I*a+b|)
        # if current_image is not in 8 bits, we need to rescale
        min_val = self.filter_params.black_level.float
        max_val = self.filter_params.white_level.float

        if min_val != 0 or max_val != 1 or current_image.precision!=8:
            min_val = self.filter_params.black_level.float
            max_val = self.filter_params.white_level.float
            # adjust levels to precision
            precision = current_image.precision
            min_val = min_val*((1 &lt;&lt; precision)-1)
            max_val = max_val*((1 &lt;&lt; precision)-1)
            if rgb_image.dtype == np.uint32:
                # Formula a bit complicated, we need to be careful with unsigned processing
                rgb_image =np.clip(((np.clip(rgb_image, min_val, None) - min_val)*(255/(max_val-min_val)))+0.5,
                                   None, 255).astype(np.uint8)
            else:
                # to rescale: add min_val and multiply by (max_val-min_val)/255
                if min_val != 0:
                    rgb_image = cv2.add(rgb_image, (-min_val, -min_val, -min_val, 0))
                rgb_image = cv2.convertScaleAbs(rgb_image, alpha=255. / float(max_val - min_val), beta=0)

        # # if gamma changed
        # if self.filter_params.gamma.value != self.filter_params.gamma.default_value and work_image.dtype == np.uint8:
        #     gamma_coeff = self.filter_params.gamma.float
        #     # self.gamma_label.setText(&#34;Gamma  {}&#34;.format(gamma_coeff))
        #     invGamma = 1.0 / gamma_coeff
        #     table = np.array([((i / 255.0) ** invGamma) * 255 for i in np.arange(0, 256)]).astype(&#34;uint8&#34;)
        #     work_image = cv2.LUT(work_image, table)

    self.print_timing(title=&#39;apply_filters()&#39;)
    return rgb_image</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.apply_translation"><code class="name flex">
<span>def <span class="ident">apply_translation</span></span>(<span>self, crop)</span>
</code></dt>
<dd>
<div class="desc"><p>:param crop:
:return: the new crop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_translation(self, crop):
    &#34;&#34;&#34;
    :param crop:
    :return: the new crop
    &#34;&#34;&#34;
    # Apply translation
    diff_x, diff_y = self.new_translation()
    diff_y = - diff_y
    # print(&#34; new translation {} {}&#34;.format(diff_x, diff_y))
    # apply the maximal allowed translation
    tr_x = float(diff_x) / self.width()
    tr_y = float(diff_y) / self.height()
    tr_x = clip_value(tr_x, crop[2]-1, crop[0])
    tr_y = clip_value(tr_y, crop[3]-1, crop[1])
    # normalized position relative to the full image
    crop[0] -= tr_x
    crop[1] -= tr_y
    crop[2] -= tr_x
    crop[3] -= tr_y</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.apply_zoom"><code class="name flex">
<span>def <span class="ident">apply_zoom</span></span>(<span>self, crop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_zoom(self, crop):
    (height, width) = self._image.data.shape[:2]
    # print(f&#34;height, width = {height, width}&#34;)
    # Apply zoom
    coeff = 1.0/self.new_scale(self.mouse_zy, height)
    # zoom from the center of the image
    center = self.zoom_center
    new_crop = center + (crop - center) * coeff

    # print(&#34;new crop zoom 1 {}&#34;.format(new_crop))

    # allow crop increase based on the available space
    label_width = self.width()
    # print(f&#34;label_width {label_width}&#34;)
    label_height = self.height()

    new_width = width * coeff
    new_height = height * coeff

    ratio_width = float(label_width) / new_width
    ratio_height = float(label_height) / new_height

    # print(f&#34; ratio_width {ratio_width} ratio_height {ratio_height}&#34;)
    ratio = min(ratio_width, ratio_height)

    if ratio_width&lt;ratio_height:
        # margin to increase height
        margin_pixels = label_height/ratio - new_height
        margin_height = margin_pixels/height
        new_crop[1] -= margin_height/2
        new_crop[3] += margin_height/2
    else:
        # margin to increase width
        margin_pixels = label_width/ratio - new_width
        margin_width = margin_pixels/width
        new_crop[0] -= margin_width/2
        new_crop[2] += margin_width/2
    # print(&#34;new crop zoom 2 {}&#34;.format(new_crop))

    return new_crop</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.check_translation"><code class="name flex">
<span>def <span class="ident">check_translation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method computes the translation really applied based on the current requested translation
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_translation(self):
    &#34;&#34;&#34;
    This method computes the translation really applied based on the current requested translation
    :return:
    &#34;&#34;&#34;
    # Apply zoom
    crop = self.apply_zoom(self.output_crop)

    # Compute the translation that is really applied after applying the constraints
    diff_x, diff_y = self.new_translation()
    diff_y = - diff_y
    # print(&#34; new translation {} {}&#34;.format(diff_x, diff_y))
    # apply the maximal allowed translation
    w, h = self.width(), self.height()
    diff_x = clip_value(diff_x, w*(crop[2]-1), w*(crop[0]))
    diff_y = - clip_value(diff_y, h*(crop[3]-1), h*(crop[1]))
    # normalized position relative to the full image
    return diff_x, diff_y</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.draw_cursor"><code class="name flex">
<span>def <span class="ident">draw_cursor</span></span>(<span>self, cropped_image_shape, crop_xmin, crop_ymin, rect, painter, full=False) ‑> Optional[Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>:param cropped_image_shape: dimensions of current crop
:param crop_xmin: left pixel of current crop
:param crop_ymin: top pixel of current crop
:param rect: displayed image area
:param painter:
:return:
tuple: (posx, posy) image pixel position of the cursor, if None cursor is out of image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_cursor(self, cropped_image_shape, crop_xmin, crop_ymin, rect, painter, full=False) -&gt; Optional[Tuple[int, int]]:
    &#34;&#34;&#34;
    :param cropped_image_shape: dimensions of current crop
    :param crop_xmin: left pixel of current crop
    :param crop_ymin: top pixel of current crop
    :param rect: displayed image area
    :param painter:
    :return:
        tuple: (posx, posy) image pixel position of the cursor, if None cursor is out of image
    &#34;&#34;&#34;
    # Draw cursor
    if self.display_timing: self.start_timing()
    # get image position
    (height, width) = cropped_image_shape[:2]
    im_x = int((self.mouse_x -rect.x())/rect.width()*width)
    im_y = int((self.mouse_y -rect.y())/rect.height()*height)

    pos_from_im_x = int((im_x+0.5)*rect.width()/width +rect.x())
    pos_from_im_y = int((im_y+0.5)*rect.height()/height+rect.y())

    # ratio = self.screen().devicePixelRatio()
    # print(&#34;ratio = {}&#34;.format(ratio))
    pos_x = pos_from_im_x  # *ratio
    pos_y = pos_from_im_y  # *ratio
    length_percent = 0.04
    # use percentage of the displayed image dimensions
    length = int(max(self.width(),self.height())*length_percent)
    pen_width = 2 if full else 3
    color = QtGui.QColor(0, 255, 255, 200)
    pen = QtGui.QPen()
    pen.setColor(color)
    pen.setWidth(pen_width)
    painter.setPen(pen)
    if not full:
        painter.drawLine(pos_x-length, pos_y, pos_x+length, pos_y)
        painter.drawLine(pos_x, pos_y-length, pos_x, pos_y+length)
    else:
        painter.drawLine(rect.x(), pos_y, rect.x()+rect.width(), pos_y)
        painter.drawLine(pos_x, rect.y(), pos_x, rect.y()+rect.height())

    # Update text
    if im_x&gt;=0 and im_x&lt;cropped_image_shape[1] and im_y&gt;=0 and im_y&lt;cropped_image_shape[0]:
        # values = cropped_image[im_y, im_x]
        im_x += crop_xmin
        im_y += crop_ymin
        im_pos = (im_x, im_y)
    else:
        im_pos = None
    if self.display_timing: self.print_timing()
    return im_pos</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.draw_overlay_separation"><code class="name flex">
<span>def <span class="ident">draw_overlay_separation</span></span>(<span>self, cropped_image_shape, rect, painter)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_overlay_separation(self, cropped_image_shape, rect, painter):
    (height, width) = cropped_image_shape[:2]
    im_x = int((self.mouse_x - rect.x())/rect.width()*width)
    im_x = max(0, min(width - 1, im_x))
    # im_y = int((self.mouse_y - rect.y())/rect.height()*height)
    # Set position at the beginning of the pixel
    pos_from_im_x = int(im_x*rect.width()/width + rect.x())
    # pos_from_im_y = int((im_y+0.5)*rect.height()/height+ rect.y())
    pen_width = 2
    color = QtGui.QColor(255, 255, 0 , 128)
    pen = QtGui.QPen()
    pen.setColor(color)
    pen.setWidth(pen_width)
    painter.setPen(pen)
    painter.drawLine(pos_from_im_x, rect.y(), pos_from_im_x, rect.y() + rect.height())</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>self, evt)</span>
</code></dt>
<dd>
<div class="desc"><p>event(self, event: PySide6.QtCore.QEvent) -&gt; bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(self, evt):
    if self.event_recorder is not None:
        self.event_recorder.store_event(self, evt)
    return BaseWidget.event(self, evt)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.get_difference_image"><code class="name flex">
<span>def <span class="ident">get_difference_image</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_difference_image(self, verbose=True):

    factor = self.filter_params.imdiff_factor.float
    if self.paint_diff_cache is not None:
        use_cache = self.paint_diff_cache[&#39;imid&#39;] == self.image_id and \
                    self.paint_diff_cache[&#39;imrefid&#39;] == self.image_ref_id and \
                    self.paint_diff_cache[&#39;factor&#39;] == factor
    else:
        use_cache = False

    if not use_cache:
        im1 = self._image.data
        im2 = self._image_ref.data
        # TODO: get factor from parameters ...
        # factor = int(self.diff_color_slider.value())
        print(f&#39;factor = {factor}&#39;)
        print(f&#39; im1.dtype {im1.dtype} im2.dtype {im2.dtype}&#39;)
        # Fast OpenCV code
        start = get_time()
        # positive diffs in unsigned 8 bits, OpenCV puts negative values to 0
        try:
            if im1.dtype.name == &#39;uint8&#39; and im2.dtype.name == &#39;uint8&#39;:
                diff_plus = cv2.subtract(im1, im2)
                diff_minus = cv2.subtract(im2, im1)
                res = cv2.addWeighted(diff_plus, factor, diff_minus, -factor, 127)
                if verbose:
                    print(f&#34; qtImageViewer.difference_image()  took {int((get_time() - start)*1000)} ms&#34;)
                    vmin = np.min(res)
                    vmax = np.max(res)
                    print(f&#34;min-max diff = {vmin} - {vmax}&#34;)
                    histo,_ = np.histogram(res, bins=int(vmax-vmin+0.5), range=(vmin, vmax))
                    sum = 0
                    for v in range(vmin,vmax):
                        if v!=127:
                            nb = histo[v-vmin]
                            if nb &gt;0:
                                print(f&#34;{v-127}:{nb} &#34;,end=&#39;&#39;)
                                sum += nb
                    print(&#39;&#39;)
                    print(f&#39;nb pixel diff  {sum}&#39;)
                res = ViewerImage(res,  precision=self._image.precision, 
                                        downscale=self._image.downscale,
                                        channels=self._image.channels)
                self.paint_diff_cache = {  &#39;imid&#39;: self.image_id, &#39;imrefid&#39;: self.image_ref_id, 
                    &#39;factor&#39;: self.filter_params.imdiff_factor.float
                }
                self.diff_image = res
            else:
                d = (im1.astype(np.float32)-im2.astype(np.float32))*factor
                d[d&lt;-127] = -127
                d[d&gt;128] = 128
                d = (d+127).astype(np.uint8)*255
                res = ViewerImage(d,  precision=8, 
                                        downscale=self._image.downscale,
                                        channels=self._image.channels)
                self.paint_diff_cache = {  &#39;imid&#39;: self.image_id, &#39;imrefid&#39;: self.image_ref_id, 
                    &#39;factor&#39;: self.filter_params.imdiff_factor.float
                }
                self.diff_image = res
        except Exception as e:
            print(f&#34;Error {e}&#34;)
            res = (im1!=im2).astype(np.uint8)*255
            res = ViewerImage(res,  precision=8, 
                                    downscale=self._image.downscale,
                                    channels=ImageFormat.CH_Y)
            self.diff_image = res

    return self.diff_image</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.keyPressEvent"><code class="name flex">
<span>def <span class="ident">keyPressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>keyPressEvent(self, event: PySide6.QtGui.QKeyEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyPressEvent(self, event):
    self.key_press_event(event, wsize=self.size())</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.keyReleaseEvent"><code class="name flex">
<span>def <span class="ident">keyReleaseEvent</span></span>(<span>self, evt)</span>
</code></dt>
<dd>
<div class="desc"><p>keyReleaseEvent(self, event: PySide6.QtGui.QKeyEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyReleaseEvent(self, evt):
    self.print_log(f&#34;evt {evt.type()}&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.mouseDoubleClickEvent"><code class="name flex">
<span>def <span class="ident">mouseDoubleClickEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>mouseDoubleClickEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseDoubleClickEvent(self, event):
    self.mouse_double_click_event(event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.mouseMoveEvent"><code class="name flex">
<span>def <span class="ident">mouseMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>mouseMoveEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseMoveEvent(self, event):
    self.mouse_move_event(event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event):
    self.mouse_press_event(event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.mouseReleaseEvent"><code class="name flex">
<span>def <span class="ident">mouseReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>mouseReleaseEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseReleaseEvent(self, event):
    self.mouse_release_event(event)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.paintEvent"><code class="name flex">
<span>def <span class="ident">paintEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>paintEvent(self, event: PySide6.QtGui.QPaintEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintEvent(self, event):
    # print(f&#34; qtImageViewer.paintEvent() {self.image_name}&#34;)
    if self.trace_calls:
        t = trace_method(self.tab)
    # try:
    if self._image is not None:
        self.paint_image()
    # except Exception as e:
    #     print(f&#34;Failed paint_image() {e}&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.paint_image"><code class="name flex">
<span>def <span class="ident">paint_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paint_image(self):
    # print(f&#34;paint_image display_timing {self.display_timing}&#34;)
    if self.trace_calls: t = trace_method(self.tab)
    self.start_timing()
    time0 = time1 = get_time()

    label_width = self.size().width()
    label_height = self.size().height()

    show_diff = self.show_image_differences and self._image is not self._image_ref and \
                self._image_ref is not None and self._image.data.shape == self._image_ref.data.shape

    c = self.update_crop()
    # check paint_cache
    if self.paint_cache is not None:
        use_cache = self.paint_cache[&#39;imid&#39;] == self.image_id and \
                    np.array_equal(self.paint_cache[&#39;crop&#39;],c) and \
                    self.paint_cache[&#39;labelw&#39;] == label_width and \
                    self.paint_cache[&#39;labelh&#39;] == label_height and \
                    self.paint_cache[&#39;filterp&#39;].is_equal(self.filter_params) and \
                    (self.paint_cache[&#39;showhist&#39;] == self.show_histogram or not self.show_histogram) and \
                    self.paint_cache[&#39;show_diff&#39;] == show_diff and \
                    self.paint_cache[&#39;antialiasing&#39;] == self.antialiasing and \
                    not self.show_overlay
    else:
        use_cache = False

    # if show_diff, compute the image difference (put it in cache??)
    if show_diff:
        # Cache does not work well with differences
        use_cache = False
        # don&#39;t save the difference
        current_image = self.get_difference_image()
    else:
        current_image = self._image

    precision  = current_image.precision
    downscale  = current_image.downscale
    channels   = current_image.channels

    # TODO: get data based on the display ratio?
    image_data = current_image.data

    # could_use_cache = use_cache
    # if could_use_cache:
    #     print(&#34; Could use cache here ... !!!&#34;)
    # use_cache = False

    do_crop = (c[2] - c[0] != 1) or (c[3] - c[1] != 1)
    h, w  = image_data.shape[:2]
    if do_crop:
        crop_xmin = int(np.round(c[0] * w))
        crop_xmax = int(np.round(c[2] * w))
        crop_ymin = int(np.round(c[1] * h))
        crop_ymax = int(np.round(c[3] * h))
        image_data = image_data[crop_ymin:crop_ymax, crop_xmin:crop_xmax]
    else:
        crop_xmin = crop_ymin = 0
        crop_xmax = w
        crop_ymax = h

    cropped_image_shape = image_data.shape
    self.add_time(&#39;crop&#39;, time1)

    # time1 = get_time()
    image_height, image_width  = image_data.shape[:2]
    ratio_width = float(label_width) / image_width
    ratio_height = float(label_height) / image_height
    ratio = min(ratio_width, ratio_height)
    display_width = int(round(image_width * ratio))
    display_height = int(round(image_height * ratio))

    if self.show_overlay and self._image_ref is not self._image and self._image_ref and \
        self._image.data.shape == self._image_ref.data.shape:
        # to create the overlay rapidly, we will mix the two images based on the current cursor position
        # 1. convert cursor position to image position
        (height, width) = cropped_image_shape[:2]
        # compute rect
        rect = QtCore.QRect(0, 0, display_width, display_height)
        devRect = QtCore.QRect(0, 0, self.evt_width, self.evt_height)
        rect.moveCenter(devRect.center())
        im_x = int((self.mouse_x - rect.x()) / rect.width() * width)
        im_x = max(0,min(width-1, im_x))
        # im_y = int((self.mouse_y - rect.y()) / rect.height() * height)
        # We need to have a copy here .. slow, better option???
        image_data = np.copy(image_data)
        image_data[:, :im_x] = self._image_ref.data[crop_ymin:crop_ymax, crop_xmin:(crop_xmin+im_x)]

    resize_applied = False
    if not use_cache:
        anti_aliasing = ratio &lt; 1
        #self.print_log(&#34;ratio is {:0.2f}&#34;.format(ratio))
        use_opencv_resize = anti_aliasing
        # enable this as optional?
        # opencv_downscale_interpolation = opencv_fast_interpolation
        opencv_fast_interpolation = cv2.INTER_NEAREST
        if self.antialiasing:
            opencv_downscale_interpolation = cv2.INTER_AREA
        else:
            opencv_downscale_interpolation = cv2.INTER_NEAREST
        # opencv_upscale_interpolation   = cv2.INTER_LINEAR
        opencv_upscale_interpolation   = opencv_fast_interpolation
        # self.print_time(&#39;several settings&#39;, time1, start_time)

        # self.print_log(&#34;use_opencv_resize {} channels {}&#34;.format(use_opencv_resize, current_image.channels))
        # if ratio&lt;1 we want anti aliasing and we want to resize as soon as possible to reduce computation time
        if use_opencv_resize and not resize_applied and channels == ImageFormat.CH_RGB:

            prev_shape = image_data.shape
            initial_type = image_data.dtype
            if image_data.dtype != np.uint8:
                print(f&#34;image_data type {type(image_data)} {image_data.dtype}&#34;)
                image_data = image_data.astype(np.float32)

            # if ratio is &gt;2, start with integer downsize which is much faster
            # we could add this condition opencv_downscale_interpolation==cv2.INTER_AREA
            if ratio&lt;=0.5:
                if image_data.shape[0]%2!=0 or image_data.shape[1]%2 !=0:
                    # clip image to multiple of 2 dimension
                    image_data = image_data[:2*(image_data.shape[0]//2),:2*(image_data.shape[1]//2)]
                start_0 = get_time()
                resized_image = cv2.resize(image_data, (image_width&gt;&gt;1, image_height&gt;&gt;1),
                                        interpolation=opencv_downscale_interpolation)
                if self.display_timing:
                    print(f&#39; === qtImageViewer: ratio {ratio:0.2f} paint_image() OpenCV resize from &#39;
                        f&#39;{current_image.data.shape} to &#39;
                        f&#39;{resized_image.shape} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)
                image_data = resized_image
                if ratio&lt;=0.25:
                    if image_data.shape[0]%2!=0 or image_data.shape[1]%2 !=0:
                        # clip image to multiple of 2 dimension
                        image_data = image_data[:2*(image_data.shape[0]//2),:2*(image_data.shape[1]//2)]
                    start_0 = get_time()
                    resized_image = cv2.resize(image_data, (image_width&gt;&gt;2, image_height&gt;&gt;2),
                                            interpolation=opencv_downscale_interpolation)
                    if self.display_timing:
                        print(f&#39; === qtImageViewer: ratio {ratio:0.2f} paint_image() OpenCV resize from &#39;
                            f&#39;{current_image.data.shape} to &#39;
                            f&#39;{resized_image.shape} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)
                    image_data = resized_image

            time1 = get_time()
            start_0 = get_time()
            resized_image = cv2.resize(image_data, (display_width, display_height),
                                    interpolation=opencv_downscale_interpolation)
            if self.display_timing:
                print(f&#39; === qtImageViewer: paint_image() OpenCV resize from {image_data.shape} to &#39;
                    f&#39;{resized_image.shape} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)

            image_data = resized_image.astype(initial_type)
            resize_applied = True
            self.add_time(&#39;cv2.resize&#39;,time1)

        current_image = ViewerImage(image_data,  precision=precision, downscale=downscale, channels=channels)
        if self.show_stats:
            # Output RGB from input
            ch = self._image.channels
            data_shape = current_image.data.shape
            if len(data_shape)==2:
                print(f&#34;input average {np.average(current_image.data)}&#34;)
            if len(data_shape)==3:
                for c in range(data_shape[2]):
                    print(f&#34;input average ch {c} {np.average(current_image.data[:,:,c])}&#34;)
        current_image = self.apply_filters(current_image)

        # Compute the histogram here, with the smallest image!!!
        if self.show_histogram:
            # previous version only python with its modules
            # histograms  = self.compute_histogram    (current_image, show_timings=self.display_timing)
            # new version with bound C++ code and openMP: much faster
            histograms = self.compute_histogram_Cpp(current_image, show_timings=self.display_timing)
        else:
            histograms = None

        # try to resize anyway with opencv since qt resizing seems too slow
        if not resize_applied and BaseWidget is not QOpenGLWidget:
            time1 = get_time()
            start_0 = get_time()
            prev_shape = current_image.shape
            current_image = cv2.resize(current_image, (display_width, display_height),
                                       interpolation=opencv_upscale_interpolation)
            if self.display_timing:
                print(f&#39; === qtImageViewer: paint_image() OpenCV resize from {prev_shape} to &#39;
                    f&#39;{(display_height, display_width)} --&gt; {int((get_time()-start_0)*1000)} ms&#39;)
                self.add_time(&#39;cv2.resize&#39;,time1)

        # no need for more resizing
        resize_applied = True

        # Conversion from numpy array to QImage
        # version 1: goes through PIL image
        # version 2: use QImage constructor directly, faster
        # time1 = get_time()

    else:
        resize_applied = True
        current_image = self.paint_cache[&#39;current_image&#39;]
        histograms = self.paint_cache[&#39;histograms&#39;]
        # histograms2 = self.paint_cache[&#39;histograms2&#39;]

    # if could_use_cache:
    #     print(f&#34; ======= current_image equal ? {np.array_equal(self.paint_cache[&#39;current_image&#39;],current_image)}&#34;)

    if not use_cache and not self.show_overlay:
        # cache_time = get_time()
        fp = ImageFilterParameters()
        fp.copy_from(self.filter_params)
        self.paint_cache = {
            &#39;imid&#39;: self.image_id,
            &#39;imrefid&#39;: self.image_ref_id,
            &#39;crop&#39;: c, &#39;labelw&#39;: label_width, &#39;labelh&#39;: label_height,
            &#39;filterp&#39;: fp, &#39;showhist&#39;: self.show_histogram,
            &#39;histograms&#39;: histograms, 
            # &#39;histograms2&#39;: histograms2, 
            &#39;current_image&#39;: current_image,
            &#39;show_diff&#39; : show_diff,
            &#39;antialiasing&#39;: self.antialiasing
            }
        # print(f&#34;create cache data took {int((get_time() - cache_time) * 1000)} ms&#34;)

    if not current_image.flags[&#39;C_CONTIGUOUS&#39;]:
        current_image = np.require(current_image, np.uint8, &#39;C&#39;)
    qimage = QtGui.QImage(current_image.data, current_image.shape[1], current_image.shape[0],
                                current_image.strides[0], QtGui.QImage.Format_RGB888)
    # self.add_time(&#39;QtGui.QPixmap&#39;,time1)

    assert resize_applied, &#34;Image resized should be applied at this point&#34;
    # if not resize_applied:
    #     printf(&#34;*** We should never get here ***&#34;)
    #     time1 = get_time()
    #     if anti_aliasing:
    #         qimage = qimage.scaled(display_width, display_height, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
    #     else:
    #         qimage = qimage.scaled(display_width, display_height, QtCore.Qt.KeepAspectRatio)
    #     self.add_time(&#39;qimage.scaled&#39;, time1)
    #     resize_applied = True

    if self.save_image_clipboard:
        self.print_log(&#34;exporting to clipboard&#34;)
        self.clipboard.setImage(qimage, mode=QtGui.QClipboard.Clipboard)

    painter : QtGui.QPainter = QtGui.QPainter()

    painter.begin(self)
    if BaseWidget is QOpenGLWidget:
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

    # TODO: check that this condition is not needed
    if BaseWidget is QOpenGLWidget:
        rect = QtCore.QRect(0,0, display_width, display_height)
    else:
        rect = QtCore.QRect(qimage.rect())
    devRect = QtCore.QRect(0, 0, self.evt_width, self.evt_height)
    rect.moveCenter(devRect.center())

    time1 = get_time()
    if BaseWidget is QOpenGLWidget:
        painter.drawImage(rect, qimage)
    else:
        painter.drawImage(rect.topLeft(), qimage)
    self.add_time(&#39;painter.drawImage&#39;,time1)

    if self.show_overlay:
        self.draw_overlay_separation(cropped_image_shape, rect, painter)

    # Draw cursor
    im_pos = None
    if self.show_cursor:
        im_pos = self.draw_cursor(cropped_image_shape, 
                                  crop_xmin, 
                                  crop_ymin, 
                                  rect, 
                                  painter, 
                                  full = self.show_intensity_line,
                                  )

    if self.show_intensity_line:
        (height, width) = cropped_image_shape[:2]
        im_y = int((self.mouse_y -rect.y())/rect.height()*height)
        im_y += crop_ymin
        im_shape = self._image.data.shape
        # Horizontal display
        if im_y&gt;=0 and im_y&lt;im_shape[0] and crop_xmin&gt;=0 and crop_xmin+cropped_image_shape[1]&lt;=im_shape[1]:
            line = self._image.data[im_y, crop_xmin:crop_xmin+cropped_image_shape[1]]
            self.display_intensity_line(
                painter, 
                rect, 
                line,
                channels = self._image.channels,
                )

    self.display_text(painter, self.display_message(im_pos, ratio*self.devicePixelRatio()))

    # draw histogram
    if self.show_histogram:
        self.display_histogram(histograms, 1,  painter, rect, show_timings=self.display_timing)
        # self.display_histogram(histograms2, 2, painter, rect, show_timings=self.display_timing)

    painter.end()
    self.print_timing()

    if self.display_timing:
        print(f&#34; paint_image took {int((get_time()-time0)*1000)} ms&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.resizeEvent"><code class="name flex">
<span>def <span class="ident">resizeEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Called upon window resizing: reinitialize the viewport.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resizeEvent(self, event):
    &#34;&#34;&#34;Called upon window resizing: reinitialize the viewport.
    &#34;&#34;&#34;
    if self.trace_calls:
        t = trace_method(self.tab)
    self.print_log(f&#34;resize {event.size()}  self {self.width()} {self.height()}&#34;)
    self.evt_width = event.size().width()
    self.evt_height = event.size().height()
    BaseWidget.resizeEvent(self, event)
    self.print_log(f&#34;resize {event.size()}  self {self.width()} {self.height()}&#34;)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.set_image"><code class="name flex">
<span>def <span class="ident">set_image</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image(self, image):
    super().set_image(image)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>show(self) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self):
    if BaseWidget==QOpenGLWidget:
        self.update()
    BaseWidget.show(self)</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.update_crop"><code class="name flex">
<span>def <span class="ident">update_crop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_crop(self):
    # Apply zoom
    new_crop = self.apply_zoom(self.output_crop)
    # print(f&#34;update_crop {self.output_crop} --&gt; {new_crop}&#34;)
    # Apply translation
    self.apply_translation(new_crop)
    new_crop = np.clip(new_crop, 0, 1)
    # print(&#34;move new crop {}&#34;.format(new_crop))
    # print(f&#34;output_crop {self.output_crop} new crop {new_crop}&#34;)
    return new_crop</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.update_crop_new"><code class="name flex">
<span>def <span class="ident">update_crop_new</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_crop_new(self):
    # 1. transform crop to display coordinates
    
    # Apply zoom
    new_crop = self.apply_zoom(self.output_crop)
    # print(f&#34;update_crop {self.output_crop} --&gt; {new_crop}&#34;)
    # Apply translation
    self.apply_translation(new_crop)
    new_crop = np.clip(new_crop, 0, 1)
    # print(&#34;move new crop {}&#34;.format(new_crop))
    # print(f&#34;output_crop {self.output_crop} new crop {new_crop}&#34;)
    return new_crop</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.viewer_update"><code class="name flex">
<span>def <span class="ident">viewer_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewer_update(self):
    if BaseWidget is QOpenGLWidget:
        self.paint_image()
        self.repaint()
    else:
        self.update()</code></pre>
</details>
</dd>
<dt id="qimview.image_viewers.QTImageViewer.wheelEvent"><code class="name flex">
<span>def <span class="ident">wheelEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>wheelEvent(self, event: PySide6.QtGui.QWheelEvent) -&gt; None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wheelEvent(self, event):
    self.mouse_wheel_event(event)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qimview.image_viewers.image_viewer.ImageViewer" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer">ImageViewer</a></b></code>:
<ul class="hlist">
<li><code><a title="qimview.image_viewers.image_viewer.ImageViewer.display_histogram" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.display_histogram">display_histogram</a></code></li>
<li><code><a title="qimview.image_viewers.image_viewer.ImageViewer.find_in_layout" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.find_in_layout">find_in_layout</a></code></li>
<li><code><a title="qimview.image_viewers.image_viewer.ImageViewer.synchronize" href="image_viewer.html#qimview.image_viewers.image_viewer.ImageViewer.synchronize">synchronize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qimview.image_viewers.ViewerType"><code class="flex name class">
<span>class <span class="ident">ViewerType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ViewerType(Enum):
    QT_VIEWER             = auto()
    OPENGL_VIEWER         = auto()
    OPENGL_SHADERS_VIEWER = auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qimview.image_viewers.ViewerType.OPENGL_SHADERS_VIEWER"><code class="name">var <span class="ident">OPENGL_SHADERS_VIEWER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qimview.image_viewers.ViewerType.OPENGL_VIEWER"><code class="name">var <span class="ident">OPENGL_VIEWER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qimview.image_viewers.ViewerType.QT_VIEWER"><code class="name">var <span class="ident">QT_VIEWER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qimview" href="../index.html">qimview</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="qimview.image_viewers.gl_image_viewer" href="gl_image_viewer.html">qimview.image_viewers.gl_image_viewer</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_base" href="gl_image_viewer_base.html">qimview.image_viewers.gl_image_viewer_base</a></code></li>
<li><code><a title="qimview.image_viewers.gl_image_viewer_shaders" href="gl_image_viewer_shaders.html">qimview.image_viewers.gl_image_viewer_shaders</a></code></li>
<li><code><a title="qimview.image_viewers.image_filter_parameters" href="image_filter_parameters.html">qimview.image_viewers.image_filter_parameters</a></code></li>
<li><code><a title="qimview.image_viewers.image_filter_parameters_gui" href="image_filter_parameters_gui.html">qimview.image_viewers.image_filter_parameters_gui</a></code></li>
<li><code><a title="qimview.image_viewers.image_viewer" href="image_viewer.html">qimview.image_viewers.image_viewer</a></code></li>
<li><code><a title="qimview.image_viewers.multi_view" href="multi_view.html">qimview.image_viewers.multi_view</a></code></li>
<li><code><a title="qimview.image_viewers.qt_image_viewer" href="qt_image_viewer.html">qimview.image_viewers.qt_image_viewer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qimview.image_viewers.GLImageViewer" href="#qimview.image_viewers.GLImageViewer">GLImageViewer</a></code></h4>
<ul class="two-column">
<li><code><a title="qimview.image_viewers.GLImageViewer.event" href="#qimview.image_viewers.GLImageViewer.event">event</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewer.initializeGL" href="#qimview.image_viewers.GLImageViewer.initializeGL">initializeGL</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewer.myPaintGL" href="#qimview.image_viewers.GLImageViewer.myPaintGL">myPaintGL</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewer.paintGL" href="#qimview.image_viewers.GLImageViewer.paintGL">paintGL</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewer.staticMetaObject" href="#qimview.image_viewers.GLImageViewer.staticMetaObject">staticMetaObject</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewer.viewer_update" href="#qimview.image_viewers.GLImageViewer.viewer_update">viewer_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qimview.image_viewers.GLImageViewerShaders" href="#qimview.image_viewers.GLImageViewerShaders">GLImageViewerShaders</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.fragmentShader_RAW" href="#qimview.image_viewers.GLImageViewerShaders.fragmentShader_RAW">fragmentShader_RAW</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.fragmentShader_RGB" href="#qimview.image_viewers.GLImageViewerShaders.fragmentShader_RGB">fragmentShader_RGB</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.initializeGL" href="#qimview.image_viewers.GLImageViewerShaders.initializeGL">initializeGL</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.myPaintGL" href="#qimview.image_viewers.GLImageViewerShaders.myPaintGL">myPaintGL</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.paintGL" href="#qimview.image_viewers.GLImageViewerShaders.paintGL">paintGL</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.setBufferData" href="#qimview.image_viewers.GLImageViewerShaders.setBufferData">setBufferData</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.setVerticesBufferData" href="#qimview.image_viewers.GLImageViewerShaders.setVerticesBufferData">setVerticesBufferData</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.set_shaders" href="#qimview.image_viewers.GLImageViewerShaders.set_shaders">set_shaders</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.staticMetaObject" href="#qimview.image_viewers.GLImageViewerShaders.staticMetaObject">staticMetaObject</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.updateTransforms" href="#qimview.image_viewers.GLImageViewerShaders.updateTransforms">updateTransforms</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.vertexShader" href="#qimview.image_viewers.GLImageViewerShaders.vertexShader">vertexShader</a></code></li>
<li><code><a title="qimview.image_viewers.GLImageViewerShaders.viewer_update" href="#qimview.image_viewers.GLImageViewerShaders.viewer_update">viewer_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qimview.image_viewers.ImageFilterParameters" href="#qimview.image_viewers.ImageFilterParameters">ImageFilterParameters</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.ImageFilterParameters.copy_from" href="#qimview.image_viewers.ImageFilterParameters.copy_from">copy_from</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParameters.is_equal" href="#qimview.image_viewers.ImageFilterParameters.is_equal">is_equal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qimview.image_viewers.ImageFilterParametersGui" href="#qimview.image_viewers.ImageFilterParametersGui">ImageFilterParametersGui</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.add_blackpoint" href="#qimview.image_viewers.ImageFilterParametersGui.add_blackpoint">add_blackpoint</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.add_g_b" href="#qimview.image_viewers.ImageFilterParametersGui.add_g_b">add_g_b</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.add_g_r" href="#qimview.image_viewers.ImageFilterParametersGui.add_g_r">add_g_r</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.add_gamma" href="#qimview.image_viewers.ImageFilterParametersGui.add_gamma">add_gamma</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.add_imdiff_factor" href="#qimview.image_viewers.ImageFilterParametersGui.add_imdiff_factor">add_imdiff_factor</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.add_saturation" href="#qimview.image_viewers.ImageFilterParametersGui.add_saturation">add_saturation</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.add_whitepoint" href="#qimview.image_viewers.ImageFilterParametersGui.add_whitepoint">add_whitepoint</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.register_event_player" href="#qimview.image_viewers.ImageFilterParametersGui.register_event_player">register_event_player</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.reset_all" href="#qimview.image_viewers.ImageFilterParametersGui.reset_all">reset_all</a></code></li>
<li><code><a title="qimview.image_viewers.ImageFilterParametersGui.set_event_recorder" href="#qimview.image_viewers.ImageFilterParametersGui.set_event_recorder">set_event_recorder</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qimview.image_viewers.MultiView" href="#qimview.image_viewers.MultiView">MultiView</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.MultiView.add_context_menu" href="#qimview.image_viewers.MultiView.add_context_menu">add_context_menu</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.cache_read_images" href="#qimview.image_viewers.MultiView.cache_read_images">cache_read_images</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.check_verbosity" href="#qimview.image_viewers.MultiView.check_verbosity">check_verbosity</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.clear_buttons" href="#qimview.image_viewers.MultiView.clear_buttons">clear_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.create_buttons" href="#qimview.image_viewers.MultiView.create_buttons">create_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.find_in_layout" href="#qimview.image_viewers.MultiView.find_in_layout">find_in_layout</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.get_output_image" href="#qimview.image_viewers.MultiView.get_output_image">get_output_image</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.keyPressEvent" href="#qimview.image_viewers.MultiView.keyPressEvent">keyPressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.keyReleaseEvent" href="#qimview.image_viewers.MultiView.keyReleaseEvent">keyReleaseEvent</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.layout_buttons" href="#qimview.image_viewers.MultiView.layout_buttons">layout_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.layout_parameters" href="#qimview.image_viewers.MultiView.layout_parameters">layout_parameters</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.layout_parameters_2" href="#qimview.image_viewers.MultiView.layout_parameters_2">layout_parameters_2</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.make_mouse_double_click" href="#qimview.image_viewers.MultiView.make_mouse_double_click">make_mouse_double_click</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.make_mouse_press" href="#qimview.image_viewers.MultiView.make_mouse_press">make_mouse_press</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.mouse_release" href="#qimview.image_viewers.MultiView.mouse_release">mouse_release</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.print_log" href="#qimview.image_viewers.MultiView.print_log">print_log</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.reset_intensities" href="#qimview.image_viewers.MultiView.reset_intensities">reset_intensities</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.reset_viewers" href="#qimview.image_viewers.MultiView.reset_viewers">reset_viewers</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.setMessage" href="#qimview.image_viewers.MultiView.setMessage">setMessage</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_cache_memory_bar" href="#qimview.image_viewers.MultiView.set_cache_memory_bar">set_cache_memory_bar</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_images" href="#qimview.image_viewers.MultiView.set_images">set_images</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_key_down_callback" href="#qimview.image_viewers.MultiView.set_key_down_callback">set_key_down_callback</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_key_up_callback" href="#qimview.image_viewers.MultiView.set_key_up_callback">set_key_up_callback</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_message_callback" href="#qimview.image_viewers.MultiView.set_message_callback">set_message_callback</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_number_of_viewers" href="#qimview.image_viewers.MultiView.set_number_of_viewers">set_number_of_viewers</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_number_of_viewers_callback" href="#qimview.image_viewers.MultiView.set_number_of_viewers_callback">set_number_of_viewers_callback</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_read_size" href="#qimview.image_viewers.MultiView.set_read_size">set_read_size</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_reference_label" href="#qimview.image_viewers.MultiView.set_reference_label">set_reference_label</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_verbosity" href="#qimview.image_viewers.MultiView.set_verbosity">set_verbosity</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.set_viewer_images" href="#qimview.image_viewers.MultiView.set_viewer_images">set_viewer_images</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.show_context_menu" href="#qimview.image_viewers.MultiView.show_context_menu">show_context_menu</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.show_timing" href="#qimview.image_viewers.MultiView.show_timing">show_timing</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.show_timing_detailed" href="#qimview.image_viewers.MultiView.show_timing_detailed">show_timing_detailed</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.show_trace" href="#qimview.image_viewers.MultiView.show_trace">show_trace</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.staticMetaObject" href="#qimview.image_viewers.MultiView.staticMetaObject">staticMetaObject</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.toggle_display_profiles" href="#qimview.image_viewers.MultiView.toggle_display_profiles">toggle_display_profiles</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.toggle_fullscreen" href="#qimview.image_viewers.MultiView.toggle_fullscreen">toggle_fullscreen</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_image" href="#qimview.image_viewers.MultiView.update_image">update_image</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_image_buttons" href="#qimview.image_viewers.MultiView.update_image_buttons">update_image_buttons</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_image_intensity_event" href="#qimview.image_viewers.MultiView.update_image_intensity_event">update_image_intensity_event</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_image_parameters" href="#qimview.image_viewers.MultiView.update_image_parameters">update_image_parameters</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_label_fonts" href="#qimview.image_viewers.MultiView.update_label_fonts">update_label_fonts</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_layout" href="#qimview.image_viewers.MultiView.update_layout">update_layout</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_reference" href="#qimview.image_viewers.MultiView.update_reference">update_reference</a></code></li>
<li><code><a title="qimview.image_viewers.MultiView.update_viewer_mode" href="#qimview.image_viewers.MultiView.update_viewer_mode">update_viewer_mode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qimview.image_viewers.QTImageViewer" href="#qimview.image_viewers.QTImageViewer">QTImageViewer</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.QTImageViewer.apply_filters" href="#qimview.image_viewers.QTImageViewer.apply_filters">apply_filters</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.apply_translation" href="#qimview.image_viewers.QTImageViewer.apply_translation">apply_translation</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.apply_zoom" href="#qimview.image_viewers.QTImageViewer.apply_zoom">apply_zoom</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.check_translation" href="#qimview.image_viewers.QTImageViewer.check_translation">check_translation</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.draw_cursor" href="#qimview.image_viewers.QTImageViewer.draw_cursor">draw_cursor</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.draw_overlay_separation" href="#qimview.image_viewers.QTImageViewer.draw_overlay_separation">draw_overlay_separation</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.event" href="#qimview.image_viewers.QTImageViewer.event">event</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.get_difference_image" href="#qimview.image_viewers.QTImageViewer.get_difference_image">get_difference_image</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.keyPressEvent" href="#qimview.image_viewers.QTImageViewer.keyPressEvent">keyPressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.keyReleaseEvent" href="#qimview.image_viewers.QTImageViewer.keyReleaseEvent">keyReleaseEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.mouseDoubleClickEvent" href="#qimview.image_viewers.QTImageViewer.mouseDoubleClickEvent">mouseDoubleClickEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.mouseMoveEvent" href="#qimview.image_viewers.QTImageViewer.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.mousePressEvent" href="#qimview.image_viewers.QTImageViewer.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.mouseReleaseEvent" href="#qimview.image_viewers.QTImageViewer.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.paintEvent" href="#qimview.image_viewers.QTImageViewer.paintEvent">paintEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.paint_image" href="#qimview.image_viewers.QTImageViewer.paint_image">paint_image</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.resizeEvent" href="#qimview.image_viewers.QTImageViewer.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.set_image" href="#qimview.image_viewers.QTImageViewer.set_image">set_image</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.show" href="#qimview.image_viewers.QTImageViewer.show">show</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.staticMetaObject" href="#qimview.image_viewers.QTImageViewer.staticMetaObject">staticMetaObject</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.update_crop" href="#qimview.image_viewers.QTImageViewer.update_crop">update_crop</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.update_crop_new" href="#qimview.image_viewers.QTImageViewer.update_crop_new">update_crop_new</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.viewer_update" href="#qimview.image_viewers.QTImageViewer.viewer_update">viewer_update</a></code></li>
<li><code><a title="qimview.image_viewers.QTImageViewer.wheelEvent" href="#qimview.image_viewers.QTImageViewer.wheelEvent">wheelEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qimview.image_viewers.ViewerType" href="#qimview.image_viewers.ViewerType">ViewerType</a></code></h4>
<ul class="">
<li><code><a title="qimview.image_viewers.ViewerType.OPENGL_SHADERS_VIEWER" href="#qimview.image_viewers.ViewerType.OPENGL_SHADERS_VIEWER">OPENGL_SHADERS_VIEWER</a></code></li>
<li><code><a title="qimview.image_viewers.ViewerType.OPENGL_VIEWER" href="#qimview.image_viewers.ViewerType.OPENGL_VIEWER">OPENGL_VIEWER</a></code></li>
<li><code><a title="qimview.image_viewers.ViewerType.QT_VIEWER" href="#qimview.image_viewers.ViewerType.QT_VIEWER">QT_VIEWER</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>